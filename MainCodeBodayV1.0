def Main ( ) :
	global	NumSimulations , NumTicksEachSimulation , SimTick , \
			TimeError , SimError , EnergyError , PopulationError , \
			PrintFlow
#
	print "Start"
	InitializeMonitoring ( )
	CharacterizeTime ( )
	if not TimeError :
		CharacterizeSimulations ( )
		if not SimError :
			CharacterizeEnergy ( )
			if not EnergyError:
				for SimulationID in range ( 0 , NumSimulations ) :
					CharacterizePopulation ( )
					if not PopulationError :
						GenerateAgents ( )
						for SimTick in range ( 0 , NumTicksEachSimulation ) :
							if PrintFlow : print "   SimTick" , SimTick
							RandomizeClaimsAndAllocationsOrder ( )
							CalculateAgentsClaims ( )
							AllocateRedistributeEnergyToAgents ( )
							InterAgentDiscussions ( )
							AssessAdjustWorldViews ( )
							AdjustPopulation ( )
							DisplayWorld ( )
							pass
						pass
					pass
				pass
			pass
		pass
	print "End"

def InitializeMonitoring ( ) :
#
# This function sets error flags and diagnostic indicators.
#
	global	TimeError , EnergyError , SimError , AgeGenderError , BirthsDeathsError , BDIPError , BiasesError , AffinitiesError , NeedsError , PopulationError , \
			PrintFlow
# Get/set monitor/control flags.
	PrintFlow 					=	True
	TimeError					=	False
	EnergyError					=	False
	SimError					=	False
	AgeGenderError				=	False
	BirthsDeathsError			=	False
	BDIPError					=	False
	BiasesError					=	False
	AffinitiesError				=	False
	NeedsError					=	False
	PopulationError				=	False
#
	if PrintFlow : print "   InitiatlizeMonitoring"

def CharacterizeTime ( ) :
#
# This function provides all parameters basic to all time-focused data and processes.
#
	global 	MemoryTicks , MaxMessagesPerTickPerAgent , MaxMessagesPerBatch , \
			TimeError , \
			PrintFlow
#
	if PrintFlow: print "   CharacterizeTime"
# Get/set data.
	MemoryTicks 					=	2
	MaxMessagesPerTickPerAgent 		=	10
	MaxMessagesPerBatch 			=	5
#
# Verify/validate data.
#
	TimeError = False
	if	( not ( isinstance( MemoryTicks ,					int ) and MemoryTicks					>= 0 ) ) 	or \
		( not ( isinstance( MaxMessagesPerTickPerAgent , 	int ) and MaxMessagesPerTickPerAgent 	>= 0 ) )	or \
		( not ( isinstance( MaxMessagesPerBatch , 			int ) and MaxMessagesPerBatch 			>= 0 ) ) 	: TimeError = True
	if TimeError : print "WARNING: Error in Time spec. Simulation will halt."

def CharacterizeSimulations ( ) :
#
# This function will be enhanced to provide for suites of simulations, eg Monte Carlo. At this point it specifies that a single simulation scenario should be run.
#
	global 	NumSimulations , NumTicksEachSimulation , TolerableVariationLow , TolerableVariationHigh , \
			SimError , \
			PrintFlow
#
	if PrintFlow: print "   CharacterizeSimulations"
#
	NumSimulations 			=	1
	NumTicksEachSimulation	=	10
	TolerableVariationLow	=	0.025
	TolerableVariationHigh	=	0.05
#
	if	( not ( isinstance( NumSimulations ,			int ) 	and NumSimulations			> 0 ) ) 	or \
		( not ( isinstance( NumTicksEachSimulation , 	int ) 	and NumTicksEachSimulation 	> 0 ) )		or \
		( not ( isinstance( TolerableVariationLow , 	float ) and TolerableVariationLow 	> 0.0 ) )	or \
		( not ( isinstance( TolerableVariationHigh , 	float ) and TolerableVariationHigh 	> 0.0 ) )	: SimError = True
	if SimError : print "WARNING: Error in Simulation spec. Simulation will halt."
	
def CharacterizeEnergy ( ) :
#
# This function develops a complete schedule of energy to be supplied to EnergyWorld's population.
#
# Takes as input (Tick,Factor) tuples..
# All values must be numbers > 0; Factor value either integer or float.
# Tuples must have progressively increasing Ticks with progressively increasing Cycles.
# CalculateAgentClaims will fill out EnergySupply to better support CalculateClaims, .
#
	global	NumTicksEachSimulation , \
			EnergySupplySpec , EnergySupplyFactors , NumTicksEachSimulation , InitialCommunityStorageMultiple , CommunityStorageDiversionFactor , MaxCommunityStorageDepletionRate , \
			EnergyError , \
			ParameterizationError
#
	if PrintFlow: print "   CharacterizeEnergy"
# Get/set data.
	EnergySupplySpec = list ( )
	EnergySupplySpec = [ \
		( 0 , 1.0 ) , 	\
		( 2 , 0.2 ) , 	\
		( 4 , 0.1 )  	]
	InitialCommunityStorageMultiple		=	0.05 	# Will be applied to first Tick's energy supply for first Tick after History Creation period.
	CommunityStorageDiversionFactor		=	0.05 	# To be diverted from each Tick's energy allocation after.
	MaxCommunityStorageDepletionRate	=	float( 1 ) / float( NumTicksEachSimulation ) # To last the entire simulation, at minimum.
#
# Verify/validate data.
#
	for SpecIndex in range ( 0 , len( EnergySupplySpec ) ) :
		if	( not ( isinstance( EnergySupplySpec [ SpecIndex ] [ 0 ] , 	int )	and 	EnergySupplySpec [ SpecIndex ] [ 0 ] 	>= 	0 	) )		or \
			( not ( isinstance( EnergySupplySpec [ SpecIndex ] [ 1 ] , 	float ) and 	EnergySupplySpec [ SpecIndex ] [ 1 ] 	>= 	0.0 ) )		: EnergyError = True
	if		( not ( isinstance( InitialCommunityStorageMultiple , 		float )	and 	InitialCommunityStorageMultiple 		>= 	0.0	) )		or \
			( not ( isinstance( CommunityStorageDiversionFactor ,		float )	and 	CommunityStorageDiversionFactor			>= 	0.0	) )		: EnergyError = True
	if EnergyError : print "WARNING: Error in Energy spec. The simulation will hatl."
#
	EnergySupplyFactors 				=	list( )
	for SpecIndex in range ( 0 , len( EnergySupplySpec ) ) :
		Factor 							=	EnergySupplySpec [ SpecIndex ] [ 1 ]
		SameFactorTickLow 				=	EnergySupplySpec [ SpecIndex ] [ 0 ]
		SameFactorTickHigh 				=	NumTicksEachSimulation
		if SpecIndex < len( EnergySupplySpec ) - 1 :
			 SameFactorTickHigh 		=	EnergySupplySpec [ SpecIndex + 1 ] [ 0 ]
		for TickIndex in range ( SameFactorTickLow , SameFactorTickHigh ) :
			EnergySupplyFactors 		.	append( Factor )

def CharacterizePopulation ( ) :
#
# This function acquires age/gender, births/deaths, beliefs/desires/intentions/powers, affinities, needs, and biases data for generating EnergyWorld's starting population.
#
# The commented-out code block immediately below is a suggestion for how to acquire data from a file. It has not been tested and may not be correct.
# Other methods for acquiring data, e.g. from other EnergyWorld functions and from the user in real time, have not yet been explored.
#
	global	PopulationError , \
			PrintFlow
#
	if PrintFlow : print "   CharacterizePopulation"
#
	if not ( TimeError or EnergyError or SimError ) :
		PopulationError = True
		GetAndCheckAgeGenderData ( )
		if not AgeGenderError :
			GetAndCheckBirthsDeathsData ( )
			if not BirthsDeathsError :
				GetAndCheckBeliefsDesiresIntentionsPowersData ( )
				if not BDIPError :
					GetAndCheckBiasesData ( )
					if not BiasesError :
						GetAndCheckAffinitiesThoughtLeadersData ( )
						if not AffinitiesError :
							GetAndCheckNeedsData ( )
							PopulationError = False
	if PopulationError :
		print "WARNING: Error in Population spec. Simulation will halt."

def GetAndCheckAgeGenderData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	ApproximateStartingPopulation is used to generate EnergyWorld's starting population as multiples of the population defined by NominalPopulationSpec.
#	(ActualStartingPopulation will be the multiple of len(WorldViewCombinations) that is greater than or equal to ApproximateStartingPosition.)
#	MaxTick is the age after which Agents will be deleted from EnergyWorld.
#	RetirementTick is used in making some energy claims in CalculateAgentsClaims.
#	MaturityTick is the age at Agents begin to make assessments and adjustments to their worldviews.
#	NominalPopulationSpec is the basis for EnergyWorld's starting population. It specifies the relative number of males and females for each age from 0 through MaxAge.
#
	global	ApproximateStartingPopulationSize , AbsoluteMaximumPopulationSize , \
			MaxTick , RetirementTick , MaturityTick , MalePopulationFraction , PopulationCountBasis , NominalPopulationSpec , \
			AgeGenderError , \
			PrintFlow
#
	import math
#
	if PrintFlow: print "      AgeGenderData"
# Get/set data.
	ApproximateStartingPopulationSize 	=	10 # Almost ignored in favor of WorldView, AgeGender and NominalPopulation factors.
	AbsoluteMaximumPopulationSize		=	100000
	MaxTick								=	99
	RetirementTick 						=	65
	MaturityTick 						=	18
	NominalPopulationSpec 				=	list ( ) # From http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo10a-eng.htm
	PopulationCountBasis 				=	0.2 * 0.01 # StatsCan data shows % for 5-year periods.
	NominalPopulationSpec = [ \
		( 0  , 5.6 , 5.3 ) , ( 1  , 5.6 , 5.3 ) , ( 2  , 5.6 , 5.3 ) , ( 3  , 5.6 , 5.3 ) , ( 4  , 5.6 , 5.3 ) , \
		( 5  , 5.5 , 5.2 ) , ( 6  , 5.5 , 5.2 ) , ( 7  , 5.5 , 5.2 ) , ( 8  , 5.5 , 5.2 ) , ( 9  , 5.5 , 5.2 ) , \
		( 10 , 5.5 , 5.1 ) , ( 11 , 5.5 , 5.1 ) , ( 12 , 5.5 , 5.1 ) , ( 13 , 5.5 , 5.1 ) , ( 14 , 5.5 , 5.1 ) , \
		( 15 , 6.4 , 6.0 ) , ( 16 , 6.4 , 6.0 ) , ( 17 , 6.4 , 6.0 ) , ( 18 , 6.4 , 6.0 ) , ( 19 , 6.4 , 6.0 ) , \
		( 20 , 7.1 , 6.8 ) , ( 21 , 7.1 , 6.8 ) , ( 22 , 7.1 , 6.8 ) , ( 23 , 7.1 , 6.8 ) , ( 24 , 1.1 , 6.8 ) , \
		( 25 , 6.9 , 6.8 ) , ( 26 , 6.9 , 6.8 ) , ( 27 , 6.9 , 6.8 ) , ( 28 , 6.9 , 6.8 ) , ( 29 , 6.9 , 6.8 ) , \
		( 30 , 7.0 , 6.9 ) , ( 31 , 7.0 , 6.9 ) , ( 32 , 7.0 , 6.9 ) , ( 33 , 7.0 , 6.9 ) , ( 34 , 7.0 , 6.9 ) , \
		( 35 , 6.7 , 6.6 ) , ( 36 , 6.7 , 6.6 ) , ( 37 , 6.7 , 6.6 ) , ( 38 , 6.7 , 6.6 ) , ( 39 , 6.7 , 6.6 ) , \
		( 40 , 6.8 , 6.7 ) , ( 41 , 6.8 , 6.7 ) , ( 42 , 6.8 , 6.7 ) , ( 43 , 6.8 , 6.7 ) , ( 44 , 6.8 , 6.7 ) , \
		( 45 , 7.4 , 7.2 ) , ( 46 , 7.4 , 7.2 ) , ( 47 , 7.4 , 7.2 ) , ( 48 , 7.4 , 7.2 ) , ( 49 , 7.4 , 7.2 ) , \
		( 50 , 7.9 , 7.7 ) , ( 51 , 7.9 , 7.7 ) , ( 52 , 7.9 , 7.7 ) , ( 53 , 7.9 , 7.7 ) , ( 54 , 7.9 , 7.7 ) , \
		( 55 , 7.2 , 7.1 ) , ( 56 , 7.2 , 7.1 ) , ( 57 , 7.2 , 7.1 ) , ( 58 , 7.2 , 7.1 ) , ( 59 , 7.2 , 7.1 ) , \
		( 60 , 6.0 , 6.0 ) , ( 61 , 6.0 , 6.0 ) , ( 62 , 6.0 , 6.0 ) , ( 63 , 6.0 , 6.0 ) , ( 64 , 6.0 , 6.0 ) , \
		( 65 , 4.9 , 5.1 ) , ( 66 , 4.9 , 5.1 ) , ( 67 , 4.9 , 5.1 ) , ( 68 , 4.9 , 5.1 ) , ( 69 , 4.9 , 5.1 ) , \
		( 70 , 3.4 , 3.7 ) , ( 71 , 3.4 , 3.7 ) , ( 72 , 3.4 , 3.7 ) , ( 73 , 3.4 , 3.7 ) , ( 74 , 3.4 , 3.7 ) , \
		( 75 , 2.5 , 2.9 ) , ( 76 , 2.5 , 2.9 ) , ( 77 , 2.5 , 2.9 ) , ( 78 , 2.5 , 2.9 ) , ( 79 , 2.5 , 2.9 ) , \
		( 80 , 1.8 , 2.4 ) , ( 81 , 1.8 , 2.4 ) , ( 82 , 1.8 , 2.4 ) , ( 83 , 1.8 , 2.4 ) , ( 84 , 1.8 , 2.4 ) , \
		( 85 , 0.9 , 1.6 ) , ( 86 , 0.9 , 1.6 ) , ( 87 , 0.9 , 1.6 ) , ( 88 , 0.9 , 1.6 ) , ( 89 , 0.9 , 1.6 ) , \
		( 90 , 0.4 , 1.0 ) , ( 91 , 0.4 , 1.0 ) , ( 92 , 0.4 , 1.0 ) , ( 93 , 0.4 , 1.0 ) , ( 94 , 0.4 , 1.0 ) , \
		( 95 , 0.4 , 1.0 ) , ( 96 , 0.4 , 1.0 ) , ( 97 , 0.4 , 1.0 ) , ( 98 , 0.4 , 1.0 ) , ( 99 , 0.4 , 1.0 )   ]
#
	NumMales 				=	0
	NumFemales 				=	0
	NumAll					=	0
	for PopIndex in range( 0 , len( NominalPopulationSpec ) ) :
		NumMales 			=	NumMales + NominalPopulationSpec [ PopIndex ] [ 1 ]
		NumFemales 			=	NumFemales + NominalPopulationSpec [ PopIndex ] [ 2 ]
		NumAll				=	NumAll + NominalPopulationSpec [ PopIndex ] [ 1 ] + NominalPopulationSpec [ PopIndex ] [ 2 ]
	MalePopulationFraction 	=	float( NumMales ) / float( NumAll )
#
# Verify/validate data.
#
	AgeGenderError = False
	if	( not ( isinstance( ApproximateStartingPopulationSize , 			int ) 	and ApproximateStartingPopulationSize 			> 0     ) ) 	or \
	   	( not ( isinstance( MaxTick , 										int )	and MaxTick 									> 0     ) ) 	or \
		( not ( isinstance( RetirementTick , 								int )	and RetirementTick								> 0     ) ) 	or \
		( not ( isinstance( MaturityTick , 									int )	and MaturityTick								> 0     ) ) 	or \
	   	( not ( MaturityTick <= RetirementTick <= MaxTick																				    ) ) 	: AgeGenderError = True
	SequentialTickComparator = NominalPopulationSpec [ 0 ] [ 0 ] - 1
	for SpecIndex in range( 0, len( NominalPopulationSpec ) ) :
		if	( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 0 ] , int )	and NominalPopulationSpec [ SpecIndex ] [ 0 ]   >= 0    ) )		or \
	   		( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 1 ] , float )	and NominalPopulationSpec [ SpecIndex ] [ 1 ]   >= 0.0  ) )	    or \
	   		( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 2 ] , float )	and NominalPopulationSpec [ SpecIndex ] [ 2 ]   >= 0.0  ) )	    or \
	   		( not ( NominalPopulationSpec [ SpecIndex ] [ 0 ] == SequentialTickComparator + 1 ) )												    : AgeGenderError = True
		SequentialTickComparator = NominalPopulationSpec [ SpecIndex ] [ 0 ]
	if AgeGenderError : print "WARNING: Error in AgeGender spec. Simulation will halt."
	
def GetAndCheckBirthsDeathsData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	PregnancyDelayTicks is the number of Ticks that an Agent must wait after giving birth to become pregnant.
#	MaxPregnantTick is the maximum age that an Agent can become pregnant.
#	BirthRate is derived from
#	http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo02a-eng.htm (population) and # http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo04a-eng.htm (births)
#		Statistics Canada Births: 2009/10 379,373; 2010/11 376,951; 2011/12 378,752; 2012/13 383,822
#		Statistics Canada Population: 2009 33,628,600; 2010 34,005,300; 2011 34,342,800; 2012 34,754,300
#	DeathSpec is taken from http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/health30a-eng.htm (average of rates 2007-2011 per 100,000).
#	DeathRateBasis is the denomintor against which actual deaths are calculated to arrive at a percentage.
#
# Speciy and check all birth-related data. When integrated, this data should be acquired from a file or the user in real time.
#
	global	PregnancyDelayTicks , MaxPregnantTick , BirthRate , DeathRate , \
			BirthsDeathsError , \
			PrintFlow
#
	if PrintFlow: print "      BirthsDeathData"
# Get/set data.
	PregnancyDelayTicks =	2
	MaxPregnantTick		=	65
	BirthRate 			= 	round( ( float( 379390 ) / float( 33628600 ) + float( 376951 ) / float( 34005300 ) + \
									 float( 378752 ) / float( 34343800 ) + float( 383822 ) / float( 34754300 ) ) / 4.0 , 4 )
	
	DeathRate			=	round( ( float( 539.8 ) + float( 531.3 ) + float( 515.0 )  + float( 501.0 ) + float ( 489.0 ) ) / 500000.0 , 4 )
#
# Verify/validate data.
#
	if	( not ( isinstance( PregnancyDelayTicks , 	int ) 	and PregnancyDelayTicks > 0 ) ) or \
		( not ( isinstance( MaxPregnantTick , 		int ) 	and MaxPregnantTick 	> 0 ) ) or \
		( not ( isinstance( BirthRate ,				float ) and BirthRate 			> 0 ) ) or \
		( not ( isinstance( DeathRate ,				float ) and DeathRate	 		> 0 ) ) : BirthsDeathsError = True
	if BirthsDeathsError : print "WARNING: Error in BirthsDeaths spec. Simulation will halt."
	
def GetAndCheckBeliefsDesiresIntentionsPowersData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
#
# Notes:
#	At present, Desires and Intentions are coupled to ConsumptionBeliefs, and ConsumptionBeliefs and Powers are the dimensions of WorldView options.
#	SupplyBeliefsSpec defines the levels of belief that an Agent has about the supply of energy; currently this is a descriptive, not operational variable.
#	ConsumptionBeliefsSpec defines the level of belief that an Agent has about their deservedness to consume energy; this is a primary operational variable.
#	DesiresSpec defines the goals associated with the above Consumption Belief options.
#	IntentionsSpec defines the Claims that Agents will make; currently these are hard-coded (the intent is to enable algorithmic specification).
#	PowersSpec defines the level of access to Energy Allocations. Agents' claims are met in order of their Power (same-Power Agents are randomized).
#
	global	SupplyBeliefsSpec , ConsumptionBeliefsSpec , DesiresSpec , IntentionsSpec , FullClaimFactors , RetirementClaimFactors , PowersSpec , \
			TotalNominalPopulation , TotalNominalConsumption , \
			BDIPError , \
			PrintFlow
#
	if PrintFlow: print "      BDIPData"
# Get/set data.
	SupplyBeliefsSpec 					=	list ( )
	SupplyBeliefsSpec 					= 	[ \
		( "Ignore" ,						False			) ,	\
		( "No limits known" , 				1				) ,	\
		( "Unlimited in long term" , 		5				) ,	\
		( "Limited in short term" , 		10				) ,	\
		( "Maxed Out" , 					3				) ,	\
		( "Limited now" , 					1				)	]
	ConsumptionBeliefsSpec 				=	list ( )
	ConsumptionBeliefsSpec 				=	[ \
		( "Ignore" ,						False			) ,	\
		( "Luxurious" , 					1 ,		5000	) ,	\
		( "Comfortable" , 					5 ,		500		) ,	\
		( "Basic" , 						10 ,	50		) ,	\
		( "Subsistence, all needs" ,  		3 , 	5		) ,	\
		( "Subsistence, physical needs" , 	1 , 	1		) 	]
	PowersSpec 							=	list ( )
	PowersSpec 							=	[ \
		( "Ignore" ,						False			) ,	\
		( "Infinite" , 						1				) , \
		( "High" , 							5				) ,	\
		( "Medium" , 						10				) , \
		( "Low" , 							3				) ,	\
		( "Zero" , 							1				) 	]
#
	DesiresSpec 						=	list ( )
	DesiresSpec 						=	[ \
		( "Rapid securing of an exceptional lifestyle until death" ) , 		\
		( "Realistic lifestyle with secure retirement at current level" ) , \
		( "Avoid falling to subsistence level; minimal retirement" ) , 		\
		( "Minimal lifestyle capable of supporting self-actualization" ) , 	\
		( "Minimal healthy physical survival" )								]
#
	FullClaimFactors 					=	list( )
	FullClaimFactors 					=	[ \
		( 1.0 , 1.0 , 1.0 , 1.5 , 1.2 ) , 	\
		( 0.5 , 0.2 , 0.1 , 0.0 , 0.0 ) , 	\
		( 0.1 , 0.1 , 0.1 , 0.0 , 0.0 ) 	]
	RetirementClaimFactors 				=	list( )
	RetirementClaimFactors 				=	[ \
		( 1.0 , 1.0 , 1.0 , 1.2 , 1.1 ) , 	\
		( 0.2 , 0.2 , 0.0 , 0.0 , 0.0 ) , 	\
		( 0.1 , 0.0 , 0.0 , 0.0 , 0.0 ) 	]
	IntentionsSpec 						=	list( )
	IntentionsSpec 						=	[ FullClaimFactors , RetirementClaimFactors ]
#
	TotalNominalPopulation				=	0
	TotalNominalConsumption				=	0
	for BeliefIndex in range ( 1 , len( ConsumptionBeliefsSpec ) ) :
		TotalNominalPopulation			=	TotalNominalPopulation + ConsumptionBeliefsSpec [ BeliefIndex ] [ 1 ]
		TotalNominalConsumption			=	TotalNominalConsumption + ConsumptionBeliefsSpec [ BeliefIndex ] [ 1 ] * ConsumptionBeliefsSpec [ BeliefIndex ] [ 2 ]
#
# Verify/validata data.
#
	if 	( not ( isinstance( SupplyBeliefsSpec [ 0 ] [ 1 ] , 						bool ) 														    	) )		or \
		( not ( isinstance( ConsumptionBeliefsSpec [ 0 ] [ 1 ] ,					bool ) 															    ) )		or \
		( not ( isinstance( PowersSpec [ 0 ] [ 1 ] , 								bool ) 															    ) )		: BDIPError = True
	for Index in range ( 1 , len ( SupplyBeliefsSpec ) ) :
		if	( not ( isinstance( SupplyBeliefsSpec [ Index ] [ 1 ] ,					int ) 	and		SupplyBeliefsSpec [ Index ] [ 1 ]			>= 0    ) )	    or \
	   		( not ( isinstance( ConsumptionBeliefsSpec [ Index ] [ 1 ] ,			int ) 	and		ConsumptionBeliefsSpec [ Index ] [ 1 ]		>= 0    ) ) 	or \
	   		( not ( isinstance( ConsumptionBeliefsSpec [ Index ] [ 2 ] ,			int ) 	and		ConsumptionBeliefsSpec [ Index ] [ 2 ]		>= 0    ) )	    or \
	   		( not ( isinstance( PowersSpec [ Index ] [ 1 ] ,						int ) 	and		PowersSpec [ Index ] [ 1 ]					>= 0    ) )	    : BDIPError = True
	for Index1 in range ( 0 , len( FullClaimFactors ) ) :
		for Index2 in range ( 0 , 5 ) :
			 if ( not ( isinstance( FullClaimFactors [ Index1 ] [ Index2 ] , 		float ) and 	FullClaimFactors [ Index1 ] [ Index2 ] 		>= 0    ) )	    or \
			 	( not ( isinstance( RetirementClaimFactors [ Index1 ] [ Index2 ] , 	float ) and 	RetirementClaimFactors [ Index1 ] [ Index2 ]>= 0    ) )	    : BDIPError = True

	if BDIPError : print "WARNING: Error in BeliefsDesiresIntentionsPowers data values. Simuluation will halt."
	
def GetAndCheckBiasesData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	All Biases data must be float values between 0.0 and 1.0 inclusive. The Low and High values form the range for randomization of the actual effect applied.
#	RiskAcceptanceEffect incorporates a number of Cognitive Biases that collectively represent the tendency to be risk tolerant when one can gain something of value.
#	RiskAvoidanceEffect incorporates a number of Cognitive Biases that collectively represent the tendency to be risk averse when one can lose something of value.
#	BelongingnessEffect incorporates a number of Cognitive Biases that collectively represent the tendency to make oneself more like a defined group than otherwise.
#	HaloEffect incorporates a number of Cognitive Biases that collectively represent the tendency to ascribe more authority to certain individuals than others.
#	DenialEffect iincorporates a number of Cognitive Biases that collectively represent the tendency to discount the messages one receives.
#
	global	RiskAcceptanceEffectLow , RiskAcceptanceEffectHigh , RiskAvoidanceEffectLow , RiskAvoidanceEffectHigh , BelongingnessEffectLow , BelongingnessEffectHigh , \
			HaloEffectLow , HaloEffectHigh , MemoryEffectLow , MemoryEffectHigh , DenialEffectLow , DenialEffectHigh , \
			BiasesError , \
			PrintFlow
#
	if PrintFlow: print "      BiasesData"
# Get/set data.
	RiskAcceptanceEffectLow 	=	0.1
	RiskAcceptanceEffectHigh 	=	0.5
	RiskAvoidanceEffectLow 			=	0.1
	RiskAvoidanceEffectHigh 		=	0.3
	BelongingnessEffectLow 		=	0.2
	BelongingnessEffectHigh 	=	0.4
	HaloEffectLow 					=	0.1
	HaloEffectHigh 					=	0.5
	MemoryEffectLow 			=	0.3
	MemoryEffectHigh 			=	0.6
	DenialEffectLow 				=	0.1
	DenialEffectHigh 				=	0.3
#
# Verify/validata data.
#
	if	( not ( isinstance( RiskAcceptanceEffectLow ,	float ) and 1.0 >= RiskAcceptanceEffectHigh 	>= 0 ) ) or \
	   	( not ( isinstance( RiskAvoidanceEffectLow , 	float ) and 1.0 >= RiskAvoidanceEffectHigh 		>= 0 ) ) or \
		( not ( isinstance( BelongingnessEffectLow , 	float ) and 1.0 >= BelongingnessEffectHigh		>= 0 ) ) or \
		( not ( isinstance( HaloEffectLow , 			float ) and 1.0 >= HaloEffectHigh 				>= 0 ) ) or \
		( not ( isinstance( MemoryEffectLow , 			float ) and 1.0 >= MemoryEffectHigh 			>= 0 ) ) or \
		( not ( isinstance( DenialEffectLow , 			float ) and 1.0 >= DenialEffectHigh 			>= 0 ) ) : BiasesError = True
	if BiasesError : print "WARNING: Error in Biases data values. Simulation will halt."
	
def GetAndCheckAffinitiesThoughtLeadersData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	ThoughtLeaderFraction is the % of all Affinity Groups that are thought leaders, whose input to inter-agent discussions is weighted more highly than others.
#	AffinitiesSpec is a list of tuples of the form (AffinityGroupDescription,ConsumptionBeliefIndex); presently, only one ConsumptionBelief attaches to a given AffinityGroup.
#
	global	ThoughtLeaderFraction , AffinitiesSpec , \
			AffinitiesError , \
			PrintFlow
#
	if PrintFlow: print "      AffinitiesData"
# Get/set data.
	ThoughtLeaderFraction 		=	0.1
	AffinitiesSpec 				=	list( )
	AffinitiesSpec 				=	[ ( "Out for number 1" , 0 ) , ( "Life is good" , 1 ) , ( "Basic is equitable" , 2 ) , ( "Just getting by" , 3 ) , ( "In trouble" , 4 ) ]
# Verify/validate data.
	if	( not ( isinstance( ThoughtLeaderFraction , float ) and 0.0 <= ThoughtLeaderFraction <= 1.0 ) ) : AffinitiesError = True
	if AffinitiesError : print "WARNING: Error in Affinites spec. Simulation will halt."
	
def GetAndCheckNeedsData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	Needs data reflect Maslow's Hierarchy of Needs; values are in energy units.
#
	global	PhysiologicalNeedsLow , PhysiologicalNeedsHigh , SafetyNeedsLow , SafetyNeedsHigh , AttachmentNeedsLow , AttachmentNeedsHigh , FullClaimsFactors , \
			EsteemNeedsLow , EsteemNeedsHigh , ActualizationNeedsLow , ActualizationNeedsHigh , InitialWealthFactor , NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh , \
			NeedsError , \
			PrintFlow
#
	if PrintFlow: print "      NeedsData"
# Get/set data.
	PhysiologicalNeedsLow		=	75
	PhysiologicalNeedsHigh		=	100
	SafetyNeedsLow					=	50
	SafetyNeedsHigh					=	75
	AttachmentNeedsLow			=	15
	AttachmentNeedsHigh			=	20
	EsteemNeedsLow					=	10
	EsteemNeedsHigh					=	15
	ActualizationNeedsLow		=	1
	ActualizationNeedsHigh		=	5
	NeedsNotMetToleranceLow			=	1
	NeedsNotMetToleranceHigh		=	3
#
# Verify/validate data. 
#
	if	( not ( isinstance( PhysiologicalNeedsLow ,		int ) and PhysiologicalNeedsLow			>= 0 ) )	or \
		( not ( isinstance( PhysiologicalNeedsHigh ,	int ) and PhysiologicalNeedsHigh		>= 0 ) )	or \
		( not ( isinstance( SafetyNeedsLow ,			int ) and SafetyNeedsLow				>= 0 ) )	or \
		( not ( isinstance( SafetyNeedsHigh ,			int ) and SafetyNeedsHigh				>= 0 ) )	or \
		( not ( isinstance( AttachmentNeedsLow ,		int ) and AttachmentNeedsLow			>= 0 ) )	or \
		( not ( isinstance( AttachmentNeedsHigh ,		int ) and AttachmentNeedsHigh			>= 0 ) )	or \
		( not ( isinstance( EsteemNeedsLow ,			int ) and EsteemNeedsLow				>= 0 ) )	or \
		( not ( isinstance( EsteemNeedsHigh ,			int ) and EsteemNeedsHigh				>= 0 ) )	or \
		( not ( isinstance( ActualizationNeedsLow ,		int ) and ActualizationNeedsLow 		>= 0 ) )	or \
		( not ( isinstance( ActualizationNeedsHigh ,	int ) and ActualizationNeedsHigh 		>= 0 ) )	or \
		( not ( isinstance( NeedsNotMetToleranceLow , 	int ) and NeedsNotMetToleranceLow		>= 0 ) )	or \
		( not ( isinstance( NeedsNotMetToleranceHigh , 	int ) and NeedsNotMetToleranceHigh		>= 0 ) )	: NeedsError = True
	if NeedsError : print "WARNING: Error in Needs spec. Simulation will halt."

def GenerateAgents ( ) :
#
# This function generates the initial set of Agents for the current simulation.
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes: (ALgorithm under review)
#	The size of the generated population is calculated as the smallest multiple of len(WorldViewCombinations) greater than or equal to ApproximateStartingPopulation,
#	rounded up to the next multiple of len(NominalPopulation); this is done so that all unique combinations of worldviews, age and gender are faithfully replicated.
#
	import math
	import random
	import copy
#
	global	AgentData , AgentID , SupplyBeliefsSpec , ConsumptionBeliefsSpec , PowersSpec , PowerBlockData , \
			NominalPopulationSpec , StartingPopulationSize , NumberOfMalesByTick , NumberOfFemalesByTick , MaturityTick , RetirementTick , ThoughtLeaderFraction , \
			WorldViewCombinations , AffinitiesSpec , ThoughLeaderFraction , \
			RiskAcceptanceEffectLow , RiskAcceptanceEffectHigh , RiskAvoidanceEffectLow , RiskAvoidanceEffectHigh , BelongingnessEffectLow , BelongingnessEffectHigh , \
			HaloEffectLow , HaloEffectHigh , MemoryEffectLow , MemoryEffectHigh , DenialEffectLow , DenialEffectHigh , \
			MaturityTick , GestationTicks , PregnancyDelayTicks , LatestPregnancyTick, MaxPregnantTick , BirthRate , DeathRate , \
			PhysiologicalNeedsLow , PhysiologicalNeedsHigh , SafetyNeedsLow , SafetyNeedsHigh , AttachmentNeedsLow , AttachmentNeedsHigh , EsteemNeedsLow , EsteemNeedsHigh , \
			ActualizationNeedsLow , ActualizationNeedsHigh , NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh , \
			ConsumptionBeliefsSpec , PersonalData , WorldViewData , AffinityData , AffinityGroupMembers , ThoughtLeaderData , BiasesData , NeedsData , ClaimsData , AllocationsData , \
			TotalPersonalStorage , SatisfactionData , ThoughtLeaders , \
			PrintFlow
#
	if PrintFlow: print "   GenerateAgents"
#
# Determine StartingPopulationSize.
	GenerateWorldViewCombinations ( )
	ScalePopulation ( )
# Prepare to generate agents.
	AgentData 										=	list( )
	PowerBlockData 									=	list( )
	for Index in range ( 0 , len( PowersSpec ) ) :
		PowerBlockData								.	append( ( 0 , 0 ) ) # Iniital Beginning and Ending Indices of Power blocks.
	AffinityData									=	list( )
	AffinityGroupMembers							=	list( )
	for Index in range ( 0 , len( SupplyBeliefsSpec ) ) :
		AffinityGroupMembers						.	append( ( ) )
	ThoughtLeaders									=	list( )
	ClaimsData 										=	list( )
	AllocationsData 								=	list( )
	TotalPersonalStorage							=	0
	SatisfactionData								=	list( )
	AgentID											=	0
	WorldViewIndex 									=	0 # Multiple cycles of WorldViewCombinations will be used to assign WorldViews to new Agents.
#
# Create male Agents with WorldView combinations just generated; cycle through these combinations repeatedly, starting at the beginning.
#
	Gender 											=	"Male"
	PregnancyStatus 								=	"Never"
	for Age in range ( 0 , MaxTick + 1 ) :
		for Agent in range ( 0 , NumberOfMalesByTick [ Age ] ) :
			AgentID									=	AgentID + 1
			PersonalData 							=	( Age , Gender, PregnancyStatus )
# Cycle through WorldViewCombinations.
			if WorldViewIndex 						>=	len( WorldViewCombinations ) :
				WorldViewIndex 						=	0 # Cycle WorldViewCombinations.
			WorldViewData 							=	( 	WorldViewCombinations [ WorldViewIndex ] [ 0 ] , \
															WorldViewCombinations [ WorldViewIndex ] [ 1 ] , \
															WorldViewCombinations [ WorldViewIndex ] [ 2 ] )
# Add AffinityData.
			AffinityData							=	list( )
			AffinityIndex							=	WorldViewCombinations [ WorldViewIndex ] [ 1 ]
			AffinityData							.	append	( AffinityIndex )
#
			AffinityGroupMemberData					=	list( )
#			AffinityGroupMemberData					=	copy.deepcopy( AffinityGroupMembers [ AffinityIndex ] ) # Prepare to add this Agent to the correct Affnity group.
			AffinityGroupMemberData					.	append( AgentID )
			AffinityGroupMembers					.	insert( AffinityIndex , AffinityGroupMemberData ) # New AffinityGroupMembers data.
			AffinityGroupMembers					.	pop( AffinityIndex + 1 ) # Old AffinityGroupMembers data
# Add ThoughtLeaderData.
			ThoughtLeaderData						=	"No"
			if MaturityTick <= Age < RetirementTick : # 'ThoughtLeaderFraction' applies to number of Agents between MaturityTick and RetirementTick.
				if ThoughtLeaderFraction > random.random( ) : # Determine whether to make this Agent a ThoughtLeader.
					ThoughtLeaderData					=	"Yes"
					ThoughtLeaders						.	append( AgentID )
# Add randomized BiasesData.
			RiskAcceptanceEffect			 		=	round( RiskAcceptanceEffectLow + random.random ( ) 	* ( RiskAcceptanceEffectHigh - RiskAcceptanceEffectLow ) 	, 2 )
			RiskAvoidanceEffect 					=	round( RiskAvoidanceEffectLow + random.random ( ) 	* ( RiskAvoidanceEffectHigh - RiskAvoidanceEffectLow  ) 	, 2 )
			BelongingnessEffect 					=	round( BelongingnessEffectLow + random.random ( ) 	* ( BelongingnessEffectHigh - BelongingnessEffectLow ) 		, 2 )
			ThoughtLeaderEffect 					=	round( HaloEffectLow + random.random ( ) 				* ( HaloEffectHigh - HaloEffectLow ) 					, 2 )
			MemoryEffect 							=	round( MemoryEffectLow + random.random ( ) 			* ( MemoryEffectHigh - MemoryEffectLow ) 					, 2 )
			DenialEffect 							=	round( DenialEffectLow + random.random ( )			* ( DenialEffectHigh - DenialEffectLow ) 					, 2 )
			BiasesData 								=	( RiskAcceptanceEffect , RiskAvoidanceEffect , BelongingnessEffect , ThoughtLeaderEffect , MemoryEffect , DenialEffect )
# Add randomized NeedsData.
			PhysiologicalNeed 						=	round( PhysiologicalNeedsLow  + random.random ( ) 	* ( PhysiologicalNeedsHigh - PhysiologicalNeedsLow ) 		, 2 )
			SafetyNeed 								=	round( SafetyNeedsLow + random.random ( ) 			* ( SafetyNeedsLow - SafetyNeedsHigh ) 						, 2 )
			AttachmentNeed 							=	round( AttachmentNeedsLow + random.random ( ) 		* ( AttachmentNeedsHigh - AttachmentNeedsLow ) 				, 2 )
			EsteemNeed 								=	round( EsteemNeedsLow + random.random ( ) 			* ( EsteemNeedsHigh - EsteemNeedsLow ) 						, 2 )
			ActualizationNeed 						=	round( ActualizationNeedsLow + random.random ( ) 		* ( ActualizationNeedsHigh - ActualizationNeedsLow )	, 2 )
			NeedsNotMetTolerance 					=	random.randint ( NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh )
			NeedsData 								=	( PhysiologicalNeed , SafetyNeed , AttachmentNeed , EsteemNeed , ActualizationNeed , NeedsNotMetTolerance )
# Create new male Agent.
			CreateNewAgent ( )
			WorldViewIndex 							=	WorldViewIndex + 1
#
# Create female Agents. Similar to males, with added processing re births and pregnancy.
#
	Gender 											=	"Female"
#
# Make some females pregnant and make some others recently-delivered.
# Method:
#	Calculate number of females to make pregnant as BirthRate * StartingPopulation.
#	Calculate number of females that gave birth prior to the simulation as StartingPopulation * (BirthRate - DeathRate) * PregnancyDelayTicks, \
#		with PregnancyStatus = -PregnancyDelayTicks.
#	Evenly spread these over new female Agents aged MaturityTick through LatestPregnancyTick, without overlap.
#
	NumberOfFemalesToMakePregnant 					=	BirthRate * StartingPopulationSize
	NumberOfFemalesToAvoidPregnancy 				=	( BirthRate - DeathRate ) * StartingPopulationSize * PregnancyDelayTicks
	NumberOfPregnancyEligibleFemales 				=	0
	for TickIndex in range ( MaturityTick , MaxPregnantTick + 1 ) :
		NumberOfPregnancyEligibleFemales 			=	NumberOfPregnancyEligibleFemales + NumberOfFemalesByTick [ TickIndex ]
	while NumberOfFemalesToMakePregnant + NumberOfFemalesToAvoidPregnancy > NumberOfPregnancyEligibleFemales :
		NumberOfFemalesToMakePregnant 				=	NumberOfFemalesToMakePregnant - 1
		NumberOfFemalesToAvoidPregnancy 			=	NumberOfFemalesToAvoidPregnancy - 1
	NumberOfFemalesToMakePregnantEachTick 			=	int( NumberOfFemalesToMakePregnant / ( MaxPregnantTick - MaturityTick + 1 ) )
	NumberOfFemalesToAvoidPregnancyEachTick			=	int( NumberOfFemalesToAvoidPregnancy / ( MaxPregnantTick - MaturityTick + 1 ) )
#
	for Age in range ( 0 , MaxTick + 1 ) :		
		NumberOfFemalesPregnancyStatusAlteredThisTick 				=	0
		for Agent in range ( 0 , NumberOfFemalesByTick [ Age ] ) : # Create data for all females at this age.
			PregnancyStatus 										=	0 # Default.
			if MaturityTick <= TickIndex <= MaxPregnantTick : # Set pregnancy status; first block for making pregnant, second block for avoiding pregnancy.
				if NumberOfFemalesPregnancyStatusAlteredThisTick 	< NumberOfFemalesToMakePregnantEachTick :
					PregnancyStatus 								=	1
					NumberOfFemalesPregnancyStatusAlteredThisTick 	=	NumberOfFemalesPregnancyStatusAlteredThisTick + 1
				elif NumberOfFemalesPregnancyStatusAlteredThisTick 	< NumberOfFemalesToMakePregnantEachTick + NumberOfFemalesToAvoidPregnancyEachTick :
					PregnancyStatus 								=	- PregnancyDelayTicks
					NumberOfFemalesPregnancyStatusAlteredThisTick 	=	NumberOfFemalesPregnancyStatusAlteredThisTick + 1
#
			AgentID									=	AgentID + 1
			PersonalData 							= 	( Age , Gender, PregnancyStatus )
# Add WorldViewData.
			if WorldViewIndex 						>= len( WorldViewCombinations ) : WorldViewIndex = 0 # Cycle WorldViewCombinations.
			WorldViewData 							=	( 	WorldViewCombinations [ WorldViewIndex ] [ 0 ] , \
															WorldViewCombinations [ WorldViewIndex ] [ 1 ] , \
															WorldViewCombinations [ WorldViewIndex ] [ 2 ] )
# Add AffinityData, and build up AffinityGroup definitions.
			AffinityData							=	list( )
			AffinityIndex							=	WorldViewCombinations [ WorldViewIndex ] [ 1 ]
			AffinityData							.	append	( AffinityIndex )
#
			AffinityGroupMemberData					=	list( )
#			AffinityGroupMemberData					=	copy.deepcopy( AffinityGroupMembers [ AffinityIndex ] ) # Prepare to add this Agent to the correct Affnity group.
			AffinityGroupMemberData					.	append( AgentID )
			AffinityGroupMembers					.	insert( AffinityIndex , AffinityGroupMemberData ) # New AffinityGroupMembers data.
			AffinityGroupMembers					.	pop( AffinityIndex + 1 ) # Old AffinityGroupMembers data
# Add ThoughtLeaderData and build up list of population's ThoughtLeaders.
			ThoughtLeaderData						=	"No"
			if MaturityTick <= Age < RetirementTick : # 'ThoughtLeaderFraction' applies to number of Agents between MaturityTick and RetirementTick.
				if ThoughtLeaderFraction > random.random( ) : # Determine whether to make this Agent a ThoughtLeader.
					ThoughtLeaderData				=	"Yes"
					ThoughtLeaders					.	append( AgentID )
# Add randomized BiasesData.
			RiskAcceptanceEffect 					=	round( RiskAcceptanceEffectLow + random.random ( )	* ( RiskAcceptanceEffectHigh - RiskAcceptanceEffectLow ) 	, 2 )
			RiskAvoidanceEffect 					=	round( RiskAvoidanceEffectLow + random.random ( )	* ( RiskAvoidanceEffectHigh - RiskAvoidanceEffectLow  )     , 2 )
			BelongingnessEffect 					=	round( BelongingnessEffectLow + random.random ( ) 	* ( BelongingnessEffectHigh - BelongingnessEffectLow ) 		, 2 )
			ThoughtLeaderEffect 					=	round( HaloEffectLow + random.random ( ) 			* ( HaloEffectHigh - HaloEffectLow ) 					    , 2 )
			MemoryEffect 							=	round( MemoryEffectLow + random.random ( ) 			* ( MemoryEffectHigh - MemoryEffectLow ) 					, 2 )
			DenialEffect 							=	round( DenialEffectLow + random.random ( ) 			* ( DenialEffectHigh - DenialEffectLow ) 					, 2 )
			BiasesData = ( RiskAcceptanceEffect , RiskAvoidanceEffect , BelongingnessEffect , ThoughtLeaderEffect , MemoryEffect , DenialEffect )
# Add randomized NeedsData.
			PhysiologicalNeed 						=	round( PhysiologicalNeedsLow  + random.random ( ) 	* ( PhysiologicalNeedsHigh - PhysiologicalNeedsLow ) 		, 2 )
			SafetyNeed 								=	round( SafetyNeedsLow + random.random ( ) 			* ( SafetyNeedsLow - SafetyNeedsHigh ) 						, 2 )
			AttachmentNeed 							=	round( AttachmentNeedsLow + random.random ( ) 		* ( AttachmentNeedsHigh - AttachmentNeedsLow ) 				, 2 )
			EsteemNeed 								=	round( EsteemNeedsLow + random.random ( ) 			* ( EsteemNeedsHigh - EsteemNeedsLow ) 						, 2 )
			ActualizationNeed 						=	round( ActualizationNeedsLow + random.random ( ) 	* ( ActualizationNeedsHigh - ActualizationNeedsLow )     	, 2 )
			NeedsNotMetTolersance 					=	random.randint ( NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh )
			NeedsData 								=	( PhysiologicalNeed , SafetyNeed , AttachmentNeed , EsteemNeed , ActualizationNeed , NeedsNotMetTolerance )
# Create new female Agent.
			CreateNewAgent ( )
			WorldViewIndex			 				=	WorldViewIndex + 1

def CreateNewAgent ( ) :
#
# This function avoids sorting AgentData by Power (an N^2 process) by inserting a new Agent record at a randomly-chosen location in the appropriate Power block.
# PowerBlock beginning and end data is maintained in PowerBlockData
#
	import	random
#
	global	AgentData , AgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , NeedsData , ClaimsData , AllocationsData , \
			TotalPersonalStorage , SatisfactionData , PowerBlockData , \
			PrintFlow
#
	DataToInsert				=	list( )
	DataToInsert				= 	[ 	AgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , NeedsData , \
										ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ]
	PowerIndex					= 	WorldViewData [ 2 ] # Obtain new Agent's Power from WorldViewData.
	BeginningBlockIndex			=	PowerBlockData [ PowerIndex ] [ 0 ] # Obtain current starting location in AgentData of target Power block.
#
	AgentData					.	insert( BeginningBlockIndex , DataToInsert ) # Insert a new Agent into AgentData at the beginning of the relevant Power block.
#
	for PowerBlockIndex in range ( PowerIndex , len( PowersSpec ) ) : # Adjust all 'downstream' beginning and ending AgentData locations in PowerData.
		BeginningIncrement		=	0 # Don't change beginning location for the Power block just inserted into.
		if PowerBlockIndex > PowerIndex :
			BeginningIncrement 	=	1
		PowerDataItem			=	list( )
		PowerDataItem			=	PowerBlockData . pop( PowerBlockIndex )
		PowerBlockData			.	insert( PowerBlockIndex , ( ( PowerDataItem [ 0 ] + BeginningIncrement ) , ( PowerDataItem [ 1 ] + 1 ) ) )

def GenerateWorldViewCombinations ( ) :
#
# This function constructs a base list of worldviews by generating all possible combinations of SupplyBeliefs, ConsumptionBeliefs and Powers, in their relative frequencies.
# SupplyBeliefsSpec, ConsumptionBeliefsSpec and PowersSpec are lists consisting of tuples of the form (text,frequency,[consumption]); only frequency is used here.
#
	import math
#
	global	SupplyBeliefsSpec , ConsumptionBeliefsSpec , PowersSpec , WorldViewCombinations , \
			PrintFlow
#
	if PrintFlow : print "      WorldViewCombinations"
#
	WorldViewCombinations = list( )
#
	EndSupplyBeliefRange 			=	len( SupplyBeliefsSpec ) - 1 # Combinations will be generated on a shorter list, since the first row in SupplyBeliefSpec will be removed.
	if SupplyBeliefsSpec [ 0 ] [ 1 ] : # Ignore rest of SupplyBelefsSpec.
		EndSupplyBeliefRange 		=	1
	SupplyBeliefsSpec 				.	pop ( 0 )
#
	EndConsumptionBeliefRange 		=	len( ConsumptionBeliefsSpec ) - 1
	if ConsumptionBeliefsSpec [ 0 ] [ 1 ] : # Ignore rest of ConsumptionBelefsSpec.
		EndConsumptionBeliefRange 	=	1
	ConsumptionBeliefsSpec 			.	pop ( 0 )
#
	EndPowerRange 					=	len( PowersSpec ) - 1
	if PowersSpec [ 0 ] [ 1 ] : # Ignore rest of PowersSpec.
		EndPowerRange 				=	1
	PowersSpec 						.	pop ( 0 )
#
	for SupplyBeliefIndex in range ( 0 , EndSupplyBeliefRange ) :	
		for SupplyBeliefFrequency in range ( 0 , SupplyBeliefsSpec [ SupplyBeliefIndex ] [ 1 ] ) :
			for ConsumptionBeliefIndex in range ( 0 , EndConsumptionBeliefRange ) :
				for ConsumptionBeliefFrequency in range ( 0 , ConsumptionBeliefsSpec [ ConsumptionBeliefIndex ] [ 1 ] ) :
					for PowerIndex in range ( 0 , EndPowerRange ) :
						for PowerFrequency in range ( 0 , PowersSpec [ PowerIndex ] [ 1 ] ) :
							WorldViewCombinations . append ( ( SupplyBeliefIndex , ConsumptionBeliefIndex , PowerIndex ) )

def ScalePopulation ( ) :
#
# This function determines a StartingPopulationSize that maintain the relative numbers of WorldView combinations at that just determined, as well as the relative numbers
# of age and gender combinations provided. This is done by finding the Lowest Common Multiple (LCM) of len(WorldViewCombinations) and len(NominalPopulation), then applying
# the smallest multiple that exceeds ApproximateStartingPopulation.
#
# Male/Female splits are averaged from this source: http://www.statcan.gc.ca/pub/89-503-x/2010001/article/11475/tbl/tbl001-eng.htm
#
	import math
	import random
#
	global	ApproximateStartingPopulationSize , AbsoluteMaximumPopulationSize , \
			StartingPopulationSize , NominalPopulationSpec , MalePopulationFraction , PopulationCountBasis , NumberOfMalesByTick , NumberOfFemalesByTick , \
			WorldViewCombinations , TotalNominalConsumption , TotalNominalPopulation , \
			PrintFlow
#
	if PrintFlow: print "      ScalePopulation"
#
# Calculate unit size of a population featuring one full set of WorldView combintations for one full set of AgeGender combinations.
# This value is equal to the Least Common Multiple of the number of the numbers of each of these.
#
	AgeGenderCombinations 					=	int( 2 * len( NominalPopulationSpec ) )
	UnitPopulationSize 						=	( 	len( WorldViewCombinations ) * AgeGenderCombinations ) / \
													GreatestCommonDivisor ( len( WorldViewCombinations ) , AgeGenderCombinations )
	Value									=	GreatestCommonDivisor ( len( WorldViewCombinations ) , AgeGenderCombinations )
	print "         TicksThisSimulation" , NumTicksEachSimulation
	print "         AgeGenderCombinations" , AgeGenderCombinations
	print "         WorldViewCombinations" , len( WorldViewCombinations )
	print "         UnitPopulationSize" , UnitPopulationSize
#
# Calculate the number of these units required genrate a population that is not smaller than the ApproximateStartingPopulationSize.
#
	NumberOfPopulationUnits 				=	int( math.ceil( float( ApproximateStartingPopulationSize ) / float( UnitPopulationSize ) ) )
	ProvisionalPopulationSize				=	UnitPopulationSize * NumberOfPopulationUnits
	print "         ApproximatePopulationSize" , ApproximateStartingPopulationSize
	print "         NumberOfUnits" , NumberOfPopulationUnits
	print "         ProvisionalPopulationSize" , ProvisionalPopulationSize
#
# Since further scaling will be done using NominalPopulation values, ensure that the smallest of these results in a final population of at least 1 while preserving full sets
# of WorldView and AgeGender combinationts, by finding the smallest multiple of StartingPopulation that ensures at least 1 in every AgeGender combination.
#
	SmallestNominalPopulationValue 			=	501.0 # All NominalPopulationSpec values are 5 * % values, ie less than 501.
	for TickIndex in range ( 0 , len( NominalPopulationSpec ) ) :
		if NominalPopulationSpec [ TickIndex ] [ 1 ] < SmallestNominalPopulationValue : SmallestNominalPopulationValue = NominalPopulationSpec [ TickIndex ] [ 1 ]
		if NominalPopulationSpec [ TickIndex ] [ 2 ] < SmallestNominalPopulationValue : SmallestNominalPopulationValue = NominalPopulationSpec [ TickIndex ] [ 2 ]
	TheoreticalStartingPopulationSize 		=	max( int( round( float( SmallestNominalPopulationValue ) / float( 1000.0 ) ) ) , 1 ) * ProvisionalPopulationSize
	print "         SmallesNomPopSpec" , SmallestNominalPopulationValue
	print "         TheoreticalStartingPopulationSize" , TheoreticalStartingPopulationSize 
	NumberOfMalesByTick 					=	list ( )
	NumberOfFemalesByTick 					=	list ( )
	RunningTotalOfMales						=	0
	RunningTotalOfFemales					=	0
	MaxTotalOfMales							=	int( round( MalePopulationFraction * float( TheoreticalStartingPopulationSize ) , 0 ) )
	MaxTotalOfFemales						=	int( round( ( 1.0 - float( MalePopulationFraction ) ) * float( TheoreticalStartingPopulationSize ) , 0 ) )
	for TickIndex in range ( 0 , len( NominalPopulationSpec ) ) : # Adjust for %, replication of 5-year StatsCan data, and unequal gender split.
		ProposedNumberOfMalesToAdd			=	int( math.ceil(	float( TheoreticalStartingPopulationSize ) * \
																float( NominalPopulationSpec [ TickIndex ] [ 1 ] ) * PopulationCountBasis * MalePopulationFraction ) )
		NumberOfMalesThisTick				=	min( ProposedNumberOfMalesToAdd , MaxTotalOfMales - RunningTotalOfMales )
		NumberOfMalesByTick					.	append ( NumberOfMalesThisTick )
		RunningTotalOfMales					=	RunningTotalOfMales + NumberOfMalesThisTick
		ProposedNumberOfFemalesToAdd		=	int( math.ceil(	float( TheoreticalStartingPopulationSize ) * float( NominalPopulationSpec [ TickIndex ] [ 1 ] ) * \
																PopulationCountBasis * ( 1.0 - float( MalePopulationFraction ) ) ) )
		NumberOfFemalesThisTick				=	min( ProposedNumberOfFemalesToAdd , MaxTotalOfFemales - RunningTotalOfFemales )
		NumberOfFemalesByTick  				.	append ( NumberOfFemalesThisTick )
		RunningTotalOfFemales				=	RunningTotalOfFemales + NumberOfFemalesThisTick
	BottomUpStartingPopulationSize			=	RunningTotalOfMales + RunningTotalOfFemales
	print "         BottomUpStartingPopulationSize" , BottomUpStartingPopulationSize
#
	AddToMales								=	int( round( float( MalePopulationFraction ) * float( TheoreticalStartingPopulationSize - BottomUpStartingPopulationSize ) ) )
	AddToFemales							=	int( round( float( 1.0 - MalePopulationFraction ) * float( TheoreticalStartingPopulationSize - BottomUpStartingPopulationSize ) ) )
	for TickIndex in range ( 0 , AddToMales ) :
		PopInsertIndex						=	random.randint( 0 , MaxTick )
		NewNumber							=	NumberOfMalesByTick [ PopInsertIndex ] + 1
		NumberOfMalesByTick					.	pop( PopInsertIndex )
		NumberOfMalesByTick					.	insert( PopInsertIndex , NewNumber )
		RunningTotalOfMales					=	RunningTotalOfMales + 1
	for TickIndex in range ( 0 , AddToFemales ) :
		PopInsertIndex						=	random.randint( 0 , MaxTick )
		NewNumber							=	NumberOfFemalesByTick [ PopInsertIndex ] + 1
		NumberOfFemalesByTick 				.	pop( PopInsertIndex )
		NumberOfFemalesByTick 				.	insert( PopInsertIndex , NewNumber )
		RunningTotalOfFemales				=	RunningTotalOfFemales + 1
	StartingPopulationSize					=	RunningTotalOfMales + RunningTotalOfFemales
#
	StartingPopulationSize					=	int( min( StartingPopulationSize , AbsoluteMaximumPopulationSize ) )
	print "         FinalStartingPopulationSize" , StartingPopulationSize

def GreatestCommonDivisor ( A , B ) : # In conjunction with ScalePopulation, finds the Lowest Common Multiple of two numbers using recursion.
	if B == 0 : return ( A )
	return ( GreatestCommonDivisor ( B , A % B ) )

def RandomizeClaimsAndAllocationsOrder ( ) :
#
# This function randomizes Agent order within each power block. (Could convert to use PowerBlockData generated in Create Agent.)
# Claims will be made and allocated in this order, so Agents with higher Power will be more likely to have their Claims satisfied, though shuffled each Tick
#
	import random
#
	global	AgentData , \
			PrintFlow
#
	if PrintFlow : print "      RandomizeClaimsAllocationsOrder"
#
	EndAgentDataIndex 						=	len( AgentData ) - 1
	StartAgentIndex 						=	0
	AgentIndex 								=	0
	while AgentIndex <= EndAgentDataIndex :
		Power 								=	AgentData [ StartAgentIndex ] [ 2 ] [ 1 ]
		if AgentIndex == EndAgentDataIndex or AgentData [ AgentIndex + 1 ] [ 2 ] [ 1 ] != Power : # New Power block or end of AgentData; logic order important.
			EndAgentIndex 					=	AgentIndex
#
# Shuffle each Power block using the Fisher-Yates Algorithm (see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle):
#	To shuffle an array a of n elements (indices 0 to n-1)
#	do for i from n-1 to 1
#		j = random integer with 0 <= j <= i
#		exchange a[j] and a[i]
#
			for ShuffleIndex in range ( StartAgentIndex , EndAgentIndex ) :
				InverseShuffleIndex 		=	EndAgentIndex - ShuffleIndex - 1
				RandomShuffleIndex 			=	StartAgentIndex + random.randint ( 0 , InverseShuffleIndex )	
				FirstAgentToMove 			=	AgentData . pop( ShuffleIndex )
				if RandomShuffleIndex > ShuffleIndex : RandomShuffleIndex = RandomShuffleIndex - 1 # Upper part of list is one shorter than prior to above pop.
				SecondAgentToMove 			=	AgentData . pop( RandomShuffleIndex )
				AgentData 					.	insert( RandomShuffleIndex , FirstAgentToMove )
				AgentData 					.	insert( ShuffleIndex , SecondAgentToMove )
# Prepare for next Power block.
			StartAgentIndex 				=	EndAgentIndex + 1
		AgentIndex 							=	AgentIndex + 1

def CalculateAgentsClaims ( ) :
#
# This function calculates current-Tick Agents' Claims independently, in the order determined by RandomizeClaimsAndAllocationsOrder (can change each SimTick).
#
	import random
	import copy
#
	global	SimTick , AgentData , MemoryTicks , RetirementTick , ConsumptionBeliefsSpec , TotalNominalPopulation , TotalNominalConsumption , EnergySupplyFactors , \
			FullClaimFactors , RetirementClaimFactors , FirstTickTotalEnergy , CommunityStorage , InitialCommunityStorageMultiple, CommunityStorageDiversionFactor , \
			PrintFlow
#
	if PrintFlow :
		print "      AgentsMakeClaims"
	TotalEnergySupplyThisTick						=	0
	TotalClaimsThisTick								= 	0
#
	for Agent in range ( 0 , len( AgentData ) ) :
		AgentID										=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		PersonalData 								= 	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		AgentTick 									= 	copy.deepcopy( PersonalData [ 0 ] )
		AgentGender									=	copy.deepcopy( PersonalData [ 1 ] )
		AgentPregnancyStatus						=	copy.deepcopy( PersonalData [ 2 ] )
		WorldViewData 								= 	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		SupplyBeliefIndexThisAgent					=	copy.deepcopy( WorldViewData [ 0 ] )
		ConsumptionBeliefIndexThisAgent				= 	copy.deepcopy( WorldViewData [ 1 ] )
		PowerIndexThisAgent							=	copy.deepcopy( WorldViewData [ 2 ] )
		AffinityData 								= 	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		ThoughtLeaderData							=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		BiasesData 									= 	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		NeedsData 									= 	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		PhysiologicalNeedsThisAgent					= 	copy.deepcopy( NeedsData [ 0 ] )
		SafetyNeedsThisAgent						= 	copy.deepcopy( NeedsData [ 1 ] )
		AttachmentNeedsThisAgent					= 	copy.deepcopy( NeedsData [ 2 ] )
		EsteemNeedsThisAgent						= 	copy.deepcopy( NeedsData [ 3 ] )
		ActualizationNeedsThisAgent					= 	copy.deepcopy( NeedsData [ 4 ] )
		ClaimsData 									= 	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
		AllocationsData 							= 	copy.deepcopy( AgentData [ Agent ] [ 8 ] )
		TotalPersonalStorage						=	copy.deepcopy( AgentData [ Agent ] [ 9 ] )
		SatisfactionData							=	copy.deepcopy( AgentData [ Agent ] [ 10 ] )
#
		AllNeedsThisAgent							= 	PhysiologicalNeedsThisAgent + SafetyNeedsThisAgent + AttachmentNeedsThisAgent + \
														EsteemNeedsThisAgent + ActualizationNeedsThisAgent
#
# First MemoryTicks EnergySupplyThisAgent based on ConsumptionBeliefsSpec.
# After first MemoryTicks, Claims are based on past Claims.
#
		if SimTick < MemoryTicks :
			EnergySupplyThisAgent					=	float( EnergySupplyFactors [ SimTick ] ) * float( StartingPopulationSize ) / float( TotalNominalPopulation ) * \
														float( ConsumptionBeliefsSpec [ ConsumptionBeliefIndexThisAgent ] [ 2 ] )
#
#	History Creation, non-retirees.
#
		if SimTick < MemoryTicks and AgentTick < RetirementTick :
#
			if ConsumptionBeliefIndexThisAgent == 0 :
				PersonalUsageClaimThisAgent 		        =	float( EnergySupplyThisAgent ) / ( 1                + float( FullClaimFactors [ 1 ] [ 0 ] ) + float( FullClaimFactors [ 2 ] [ 0 ] ) )
				PersonalStorageClaimThisAgent		        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent == 1 :
				PersonalUsageClaimThisAgent 		        =	float( EnergySupplyThisAgent ) / ( 1                + float( FullClaimFactors [ 1 ] [ 1 ] ) + float( FullClaimFactors [ 2 ] [ 1 ] ) )
				PersonalStorageClaimThisAgent		        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent == 2 :
				PersonalUsageClaimThisAgent 	        	=	float( EnergySupplyThisAgent ) / ( 1                + float( FullClaimFactors [ 1 ] [ 2 ] ) + float( FullClaimFactors [ 2 ] [ 2 ] ) )
				PersonalStorageClaimThisAgent	        	= 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 		        	= 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent == 3 :
				PersonalUsageClaimThisAgent                 =   float( EnergySupplyThisAgent ) / ( 1                + float( FullClaimFactors [ 1 ] [ 3 ] ) + float( FullClaimFactors [ 2 ] [ 3 ] ) )
				PersonalStorageClaimThisAgent       		= 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent == 4 :
				PersonalUsageClaimThisAgent 	        	=	float( EnergySupplyThisAgent ) / ( 1                + float( FullClaimFactors [ 1 ] [ 4 ] ) + float( FullClaimFactors [ 2 ] [ 4 ] ) )
				PersonalStorageClaimThisAgent	        	= 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )                * float( FullClaimFactors [ 2 ] [ 4 ] )
#
# Normal Operation, before Retirement.
#
		if SimTick >= MemoryTicks and AgentTick < RetirementTick :
#
			if ConsumptionBeliefIndexThisAgent 	== 0 :
				MaxTotalClaimThisAgent			        	=	float( 0 )
				for MemoryIndex in range ( 0 , len( ClaimsData ) ) :
					if float( AgentData [ Agent ] [ 7 ] [ MemoryIndex ] [ 0 ] ) > MaxTotalClaimThisAgent :
						MaxTotalClaimThisAgent	        	=	float( AgentData [ Agent ] [ 7 ] [ MemoryIndex ] [ 0 ] )
				PersonalUsageClaimThisAgent			        = 	float( MaxTotalClaimThisAgent )
				PersonalStorageClaimThisAgent	        	=	float( PersonalUsageClaimThisAgent )                * 	float( FullClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )                * 	float( FullClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 1 :
				TotalClaimsThisAgent				        = 	float( 0 )
				for MemoryIndex in range ( 0 , len( ClaimsData ) ) :
					TotalClaimsThisAgent		        	=	float( TotalClaimsThisAgent ) 		                + 	float( AgentData [ Agent ] [ 7 ] [ MemoryIndex ] [ 0 ] )
				AverageTotalClaimThisAgent			        =	float( TotalClaimsThisAgent ) 		                / 	float( MemoryTicks )
				PersonalUsageClaimThisAgent 		        =	float( AverageTotalClaimThisAgent )
				PersonalStorageClaimThisAgent	           	=	float( PersonalUsageClaimThisAgent )                *   float( FullClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 		        	= 	float( PersonalUsageClaimThisAgent )                *   float( FullClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 2 :
				PersonalUsageClaimThisAgent 		        =	max( float( AgentData [ Agent ] [ 7 ] [ MemoryTicks - 1 ] [ 0 ] ) , float( AllNeedsThisAgent ) )
				PersonalStorageClaimThisAgent	    	    =	float( PersonalUsageClaimThisAgent ) 	            * 	float( FullClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent ) 	            * 	float( FullClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 3 :
				PersonalUsageClaimThisAgent 	        	=	float( AllNeedsThisAgent ) 				            * float( FullClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent	        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( FullClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 			        = 	float( PersonalUsageClaimThisAgent )            	* 	float( FullClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 4 :
				PersonalUsageClaimThisAgent 	        	=	float( PhysiologicalNeedsThisAgent )	            * 	float( FullClaimFactors [ 0 ] [ 4 ] )
				PersonalStorageClaimThisAgent	        	=	float( PersonalUsageClaimThisAgent )	            * 	float( FullClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 		        	= 	float( PersonalUsageClaimThisAgent )            	* 	float( FullClaimFactors [ 2 ] [ 4 ] )
#
# History Creation Phsae, retireees.
#
		if SimTick < MemoryTicks and AgentTick >= RetirementTick :
#
			if ConsumptionBeliefIndexThisAgent	== 0 :
				PersonalUsageClaimThisAgent 		        =	float( EnergySupplyThisAgent ) 			            / \
														        ( 1 + float( RetirementClaimFactors [ 1 ] [ 0 ] ) 	+ 	float( RetirementClaimFactors [ 2 ] [ 0 ] ) )
				PersonalStorageClaimThisAgent 	        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 		        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 1 :
				PersonalUsageClaimThisAgent 		        =	float( EnergySupplyThisAgent ) 			            / \
														        ( 1 + float( RetirementClaimFactors [ 1 ] [ 1 ] ) 	+ 	float( RetirementClaimFactors [ 2 ] [ 1 ] ) )
				PersonalStorageClaimThisAgent 	        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 			        =	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 2 :
				PersonalUsageClaimThisAgent 		        =	float( EnergySupplyThisAgent ) 			            / \
														        ( 1 + float( RetirementClaimFactors [ 1 ] [ 2 ] ) 	+ 	float( RetirementClaimFactors [ 2 ] [ 2 ] ) )
				PersonalStorageClaimThisAgent 	        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 			        =	float( PersonalUsageClaimThisAgent )            	* 	float( RetirementClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 3 :
				PersonalUsageClaimThisAgent 		        =	float( AllNeedsThisAgent ) 				            * 	float( RetirementClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent 		        =	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 	        		=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 4 :
				PersonalUsageClaimThisAgent 	        	=	float( PhysiologicalNeedsThisAgent ) 	            * 	float( RetirementClaimFactors [ 0 ] [ 4 ] )
				PersonalStorageClaimThisAgent 	        	=	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 			        =	float( PersonalUsageClaimThisAgent ) 	            * 	float( RetirementClaimFactors [ 2 ] [ 4 ] )
#
# Normal operation, retirees.
#
		if SimTick >= MemoryTicks and AgentTick >= RetirementTick :
#
			MaxTotalClaimThisAgentOverMemoryTicks	        =	0
			for MemoryIndex in range ( 0 , MemoryTicks ) :
				if float( AgentData [ Agent ] [ 7 ] [ MemoryIndex ] [ 0 ] ) > MaxTotalClaimThisAgentOverMemoryTicks :
					MaxTotalClaimThisAgentOverMemoryTicks 	=	float( AgentData [ Agent ] [ 7 ] [ MemoryIndex ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 0 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 1 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 2 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 3 :
				PersonalUsageClaimThisAgent 				=	float( AllNeedsThisAgent ) 							* 	float( RetirementClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 3 ] )			
#
			if ConsumptionBeliefIndexThisAgent	== 4 :
				PersonalUsageClaimThisAgent 				=	float( PhysiologicalNeedsThisAgent ) 				* 	float( RetirementClaimFactors [ 0 ] [ 4 ] )			
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 4 ] )
#
# Apply RiskAcceptance (usage) and RiskAvoidance (storage) Cognitive Biases.
#
#		RiskAcceptanceEffect 				= 	float( AgentData [ Agent ] [ 7 ] [ 0 ] )
#		RiskAvoidanceEffect 				= 	float( AgentData [ Agent ] [ 7 ] [ 1 ] )
#		PersonalUsageClaimThisAgent 		= 	float( PersonalUsageClaimThisAgent ) 	* 	( 	float( 1 )	+ 	RiskAcceptanceEffect 	)
#		PersonalStorageClaimThisAgent 		= 	float( PersonalStorageClaimThisAgent ) 	*	(	float( 1 ) 	- 	RiskAvoidanceEffect 	)
#		ContributionClaimThisAgent 			= 	float( ContributionClaimThisAgent ) 	* 	( 	float( 1 )	- 	RiskAvoidanceEffect 	)
#
		TotalClaimsThisAgent				= 	int( PersonalUsageClaimThisAgent ) + int( PersonalStorageClaimThisAgent ) + int( ContributionClaimThisAgent )
		TotalClaimsThisTick					=	TotalClaimsThisTick + TotalClaimsThisAgent
#
		if len( ClaimsData ) ==	MemoryTicks :
			ClaimsData						.	pop( 0 ) # Maintain MemoryTicks-length list.
		ClaimsData 							. 	append( ( 	int( PersonalUsageClaimThisAgent ) , 	int( PersonalStorageClaimThisAgent ) , \
															int( ContributionClaimThisAgent ) , 	int( TotalClaimsThisAgent ) ) )
#
		AgentData 							. 	insert( Agent , [ 	AgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , NeedsData , \
																	ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ] ) # New data.
		AgentData							.	pop( Agent + 1 ) # Old data.
#
	if PrintFlow : print "         TotalClaimsThisTick" , TotalClaimsThisTick
	if SimTick == 0:
		FirstTickTotalEnergy				=	int( TotalClaimsThisTick )

def AllocateRedistributeEnergyToAgents ( ) :
#
# This function allocates the available energy to Agents, in Power block order, randomized within Power block every SimTick.
# If there are any deficient Allocations, CommunityStorage will be used to top up to Agents' Physiological Needs in the reverse order in which they were recorded.
# Exception: All Agents' Claims in the History Creation period (MemoryTicks in length) will automatically have their Claims met, ie Allocations will be made = Claims.
#
	import copy
# 
	global	SimTick , AgentData , MemoryTicks , FirstTickTotalEnergy , EnergySupplyFactors , FirstMessageThisTick , \
			CommunityStorage , InitialCommunityStorageMultiple , CommunityStorageDiversionFactor , MaxCommunityStorageDepletionRate , \
			PrintFlow 
#
	if PrintFlow : print "      AllocateEnergyToAgents"
#
	if SimTick == 0 :
		CommunityStorage								=	float( FirstTickTotalEnergy ) * float( InitialCommunityStorageMultiple )
	TotalAllocationsThisTick							=	0
	L1DeficientPersonalUsageList						=	list( )
	L2DeficientPersonalUsageList						=	list( )
	EnergyAvailableToBeAllocatedThisTick				=	float( FirstTickTotalEnergy ) * EnergySupplyFactors [ SimTick ]
	for Agent in range ( 0 , len( AgentData ) ) :
		TotalAllocationsThisAgent						=	0
		AgentID											=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		PersonalData 									= 	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		WorldViewData 									= 	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		AffinityData 									= 	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		ThoughtLeaderData								=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		BiasesData 										= 	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		NeedsData 										= 	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		ClaimsData 										= 	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
		AllocationsData 								= 	copy.deepcopy( AgentData [ Agent ] [ 8 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ Agent ] [ 9 ] )
		SatisfactionData								=	copy.deepcopy( AgentData [ Agent ] [ 10 ] )
#
		if SimTick < MemoryTicks : # Make TotalAllocations equal to TotalClaims during History Creation period, ie cannot result in unmet Claims.
			PersonalUsageAllocationThisAgent			=	float( AgentData [ Agent ] [ 7 ] [ SimTick ] [ 0 ] )
			PersonalStorageAllocationThisAgent			=	float( AgentData [ Agent ] [ 7 ] [ SimTick ] [ 1 ] )
			ContributionAllocationThisAgent				=	float( AgentData [ Agent ] [ 7 ] [ SimTick ] [ 2 ] )
			TotalAllocationsThisAgent					=	int( PersonalUsageAllocationThisAgent ) + int( PersonalStorageAllocationThisAgent ) + int( ContributionAllocationThisAgent )
		else : # Otherwise, total available to be allocated is based on the first SimTick's total Claim/Allocation.
#
			PersonalUsageClaimThisAgent					=	float( ClaimsData [ len( ClaimsData ) - 1 ] [ 0 ] )
			if PersonalUsageClaimThisAgent <= EnergyAvailableToBeAllocatedThisTick : # Fulfill full PersonalUsageClaim for this Agent.
				PersonalUsageAllocationThisAgent		=	float( PersonalUsageClaimThisAgent )
				EnergyAvailableToBeAllocatedThisTick 	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( PersonalUsageAllocationThisAgent )
			else : # EnergyAvailable will be exhausted with this Allocation.
				PersonalUsageAllocationThisAgent 		=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
				L1DeficientPersonalUsageList			.	append( Agent ) # Will top up with PersonalStorage and CommunityStorage as needed/possible.
			TotalAllocationsThisAgent					=	TotalAllocationsThisAgent + PersonalUsageAllocationThisAgent
#
			PersonalStorageClaimThisAgent				=	float( ClaimsData [ len( ClaimsData ) - 1 ] [ 1 ] )
			if PersonalStorageClaimThisAgent <=	EnergyAvailableToBeAllocatedThisTick : # Fulfill full PersonalStorage Claim for this Agent.
				PersonalStorageAllocationThisAgent 		=	float( PersonalStorageClaimThisAgent )
				EnergyAvailableToBeAllocatedThisTick	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( PersonalStorageAllocationThisAgent )
			else: # EnergyAvailble will be exhaused with this Allocation.
				PersonalStorageAllocationThisAgent		=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
			TotalAllocationsThisAgent					=	TotalAllocationsThisAgent + PersonalStorageAllocationThisAgent
#
			ContributionClaimThisAgent					=	float( ClaimsData [ len( ClaimsData ) - 1 ] [ 2 ] )
			if ContributionClaimThisAgent <= EnergyAvailableToBeAllocatedThisTick : # FulFill full CommunityStorage Claim for this Agent.
				ContributionAllocationThisAgent		 	=	float( ContributionClaimThisAgent )
				EnergyAvailableToBeAllocatedThisTick	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( ContributionAllocationThisAgent )
			else : # EnergyAvailable will be exhausted with this Allocation.
				ContributionAllocationThisAgent		 	=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
			TotalAllocationsThisAgent					=	TotalAllocationsThisAgent + ContributionAllocationThisAgent
#
			CommunityStorage							=	CommunityStorage + EnergyAvailableToBeAllocatedThisTick
#
		if len( AllocationsData ) == MemoryTicks :
			AllocationsData								.	pop( 0 ) # Maintain MemoryTicks-length list.
		AllocationsData									.	append( ( 	int( PersonalUsageAllocationThisAgent ) , int( PersonalStorageAllocationThisAgent ) , \
				 														int( ContributionAllocationThisAgent ) , int( TotalAllocationsThisAgent ) ) )
		TotalPersonalStorage							=	int( TotalPersonalStorage ) + int( PersonalStorageAllocationThisAgent )
		AgentData										. 	insert( Agent , [ 	AgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , \
																				NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ] )
		AgentData										.	pop( Agent + 1 )
		TotalAllocationsThisTick						=	TotalAllocationsThisTick + TotalAllocationsThisAgent
#
# TopUp Energy from PersonalStorage (any order) and CommunityStorage (reverse Power order) of DeficientPersonalStorageList to ensure Physiological Needs are met as much as possible.
#
	for DeficientIndex in range ( 0 , len( L1DeficientPersonalUsageList ) ) : # Top up PersonalUsge amounts from PersonalStorage in current order.
		AgentIndex										=	L1DeficientPersonalUsageList [ DeficientIndex ]
		AgentID											=	copy.deepcopy( AgentData [ AgentIndex ] [ 0 ] )
		PersonalData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 1 ] )
		WorldViewData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 2 ] )
		AffinityData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 3 ] )
		ThoughtLeaderData								=	copy.deepcopy( AgentData [ AgentIndex ] [ 4 ] )
		BiasesData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 5 ] )
		NeedsData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 6 ] )
		ClaimsData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 7 ] )
		AllocationsData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 8 ] )
		PersonalUsageAllocationThisAgent				=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 0 ] )
		PersonalStorageAllocationThisAgent				=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 1 ] )
		ConributionAllocationThisAgent					=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 2 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ AgentIndex ] [ 9 ] )
		SatisfactionData								=	copy.deepcopy( AgentData [ AgentIndex ] [ 10 ] )
#
		PersonalUsageDeficiency							=	float( ClaimsData [ len( ClaimsData ) - 1 ] [ 0 ] ) - float( AllocationsData [ len( AllocationsData ) - 1 ] [ 0 ] )
		if PersonalUsageDeficiency <= TotalPersonalStorage :
			PersonalUsageAllocationThisAgent			=	float( PersonalUsageAllocationThisAgent )	+ 	PersonalUsageDeficiency
			TotalPersonalStorage						=	float( TotalPersonalStorage )				- 	PersonalUsageDeficiency
		else :
			PersonalUsageAllocationThisAgent			=	float( TotalPersonalStorage )
			TotalPersonalStorage						=	float( 0 )
			L2DeficientPersonalUsageList				.	append( Agent )

		ReplacementAllocationsData						=	( 	PersonalUsageAllocationThisAgent , PersonalStorageAllocationThisAgent , ContributionAllocationThisAgent , \
	 															PersonalUsageAllocationThisAgent + PersonalStorageAllocationThisAgent + ContributionAllocationThisAgent )
		AllocationsData									.	pop( )
		AllocationsData									.	append( ReplacementAllocationsData )
		AgentData										.	insert( AgentIndex , [ 	AgentID , PersonalData, WorldViewData , AffinityData, ThoughtLeaderData , \
																					BiasesData , NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ] )
		AgentData										.	pop( AgentIndex + 1 )
#
	for DeficientIndex in range ( 0 , len( L2DeficientPersonalUsageList ) ) : # Top up PersonalUsge amounts from CommunityStorage in reverse Power order.
		ReverseIndex									=	len( L2DeficientPersonalUsageList ) - DeficientIndex - 1
		AgentIndex										=	L2DeficientPersonalUsageList [ ReverseIndex ]
		AgentID											=	copy.deepcopy( AgentData [ AgentIndex ] [ 0 ] )
		PersonalData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 1 ] )
		WorldViewData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 2 ] )
		AffinityData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 3 ] )
		ThoughtLeaderData								=	copy.deepcopy( AgentData [ AgentIndex ] [ 4 ] )
		BiasesData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 5 ] )
		NeedsData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 6 ] )
		ClaimsData										=	copy.deepcopy( AgentData [ AgentIndex ] [ 7 ] )
		AllocationsData									=	copy.deepcopy( AgentData [ AgentIndex ] [ 8 ] )
		PersonalUsageAllocationThisAgent				=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 0 ] )
		PersonalStorageAllocationThisAgent				=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 1 ] )
		ConributionAllocationThisAgent					=	copy.deepcopy( AllocationsData [ len( AllocationsData ) - 1 ] [ 2 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ AgentIndex ] [ 9 ] )
		SatisfactionData								=	copy.deepcopy( AgentData [ AgentIndex ] [ 10 ] )
#
		PersonalUsageDeficiency							=	float( ClaimsData [ len(ClaimsData ) - 1 ] [ 0 ] ) - float( AllocationsData [ len( AllocationsData ) - 1 ] [ 0 ] )
		if PersonalUsageDeficiency <= CommunityStorage :
			PersonalUsageAllocationThisAgent			=	float( PersonalUsageAllocationThisAgent )	+ 	PersonalUsageDeficiency
			CommunityStorage							=	float( CommunityStorage )					- 	PersonalUsageDeficiency
		else :
			PersonalUsageAllocationThisAgent			=	float( CommunityStorage )
			CommunityStorage							=	float( 0 )
#
		ReplacementAllocationsData						=	( 	PersonalUsageAllocationThisAgent , PersonalStorageAllocationThisAgent , ContributionAllocationThisAgent , \
	 															PersonalUsageAllocationThisAgent + PersonalStorageAllocationThisAgent + ContributionAllocationThisAgent )
		AllocationsData									.	pop( )
		AllocationsData									.	append( ReplacementAllocationsData )
		AgentData										.	insert( AgentIndex , [ 	AgentID , PersonalData, WorldViewData , AffinityData, ThoughtLeaderData , \
																					BiasesData , NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ] )
		AgentData										.	pop( AgentIndex + 1 )
#
	if PrintFlow : print "         TotalAllocationsThisTick" , int( TotalAllocationsThisTick )
#
	FirstMessageThisTick 								=	list( ) # Forcing all Agents to express SatisfactionValue prior to consulting Affines.
	for Agent in range ( 0 , len ( AgentData ) ) :
		FirstMessageThisTick							.	append( "True" )

def InterAgentDiscussions ( ) :
#
# This function produces Affines-affected values for Agents' satisfaction with Allocations given their Claims in this SimTick.
#
	import random
	import copy
#
	global	AgentData , Agent , SimTick , MemoryTicks , FirstMessageThisTick , TolerableVariationLow , TolerableVariationHigh , VariationToleranceThisTick , \
			MaxMessagesPerTickPerAgent , Inbox , BatchAssessment , AffinityGroupMembers , \
			PrintFlow
#
	if PrintFlow : print "      InterAgentDiscussions"
#
	MaxMessagesThisTick									=	MaxMessagesPerTickPerAgent * len( AgentData )
	NumMessagesThisTick 								=	0
	VariationToleranceThisTick 							=	float( TolerableVariationLow ) + random.random ( ) * ( float( TolerableVariationHigh ) - float( TolerableVariationLow ) )
	InBox												=	list( ) # Reset, i.e. last Tick's messages are flushed.
	while NumMessagesThisTick <= MaxMessagesThisTick :
		for Agent in range ( 0 , len ( AgentData ) ) :
			SenderAgentID								=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
			PersonalData								=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
			WorldViewData								=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
			AffinityData								=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
			ThoughLeaderData							=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
			BiasesData									=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
			NeedsData									=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
			ClaimsData									=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
			AllocationsData								=	copy.deepcopy( AgentData [ Agent ] [ 8 ] )
			TotalPersonalStorage						=	copy.deepcopy( AgentData [ Agent ] [ 9 ] )
			SatisfactionData							=	copy.deepcopy( AgentData [ Agent ] [ 10 ] )
#
			if SimTick < MemoryTicks :
				SenderSatisfactionValue					=	0.0
			else:
				if FirstMessageThisTick [ Agent ] :
					FirstMessageThisTick				.	insert( Agent , "False" )
					FirstMessageThisTick				.	pop( Agent + 1 )
					DifferenceClaimAllocation	 		=	float( AgentData [ Agent ] [ 8 ] [ len( AllocationsData ) - 1 ] [ 3 ] ) - \
															float( AgentData [ Agent ] [ 7 ] [ len( ClaimsData ) - 1 ] [ 3 ] )
					Sign								=	+1.0
					if DifferenceClaimAllocation < 0 :
						Sign							=	-1.0
					if Sign * DifferenceClaimAllocation <= float( VariationToleranceThisTick ) :
						SenderSatisfactionValue			=	0.0
					else :
						SenderSatisfactionValue			=	float( DifferenceClaimAllocation )
# Apply BelongingnessEffect; randomized each Tick.
				else :
					EvaluateNextBatchOfAffineMessages ( ) # Sets BatchAssessment to weighted sum of all Affines' SatisfactionValues.
					SenderSatisfactionValue		 		=	SatisfactionData [ len( SatisfactionData ) - 1 ] + \
															BatchAssessment * ( BelongingnessLow + random.random ( ) * ( BelongingnessHigh - BelongingnessLow ) )
# Update SatisfactionData and AgentData.
			if len( SatisfactionData ) == MemoryTicks :
				SatisfactionData						.	pop( 0 )
			SatisfactionData							.	append( ( SenderSatisfactionValue ) ) 	
			AgentData									.	insert( Agent , \
															[ 	SenderAgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , \
																NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ] )
			AgentData									.	pop( Agent + 1 )
# Send messages to Affines.
			for AffinityGroupIndex in range ( 0 , len ( AffinityData ) ) :
				for RecipientAgentID in range ( 0 , len ( AffinityGroupMembers [ AffinityGroupIndex ] ) ) :
					if RecipientAgentID <> AgentID : # Do not send to oneself.
						InBox				 			.	append ( ( RecipientAgentID , SenderAgentID , SenderSatisfactionValue ) ) # May result in duplicates. OK?
						NumMessagesThisTick 			=	NumMessagesThisTick + 1 # Global count across all Agents this Tick; may exceed Max to ensure all Agents participate.

def EvaluateNextBatchOfMessages ( ) :
#
# This function processes messages sent to Agent (from InterAgentDiscussions, above), with 'time' limits. i.e. MaxMessagesPerBatch; unprocessed messages remain in InBox.
#
	import random
	import copy
#
	global 	AgentData , Agent , MaxMessagesPerBatch , Inbox , BatchAssessment , \
			PrintFlow
#
	BatchAssessment 									=	0
	NumMessagesProcessedThisAgentThisBatch				=	0
	for InboxIndex in range ( 0 , len ( InBox ) ) :
		if Inbox [ InboxIndex ] [ 0 ] == Agent : # Recipient is Agent.
			if NumMessagesProcessedThisAgentThisBatch <= MaxMesssagesPerBatch : # Have not yet exceeded intra-Tick limit.
				Message									=	list( )
				Message									=	copy.deepcopy( Inbox [ InboxIndex ] )
				Inbox									.	pop( InboxIndex ) # Remove message from Inbox.
				SenderAgentID							=	Message [ 1 ]
				SenderSatisfactionValue 				= 	float( Message [ 2 ] )
				MessageWeight 							=	float( 1 ) # Default.
				if AgentData [ SenderAgentID ] [ 4 ] == "Yes" : # Sender is a ThoughtLeader.
					MessageWeight 						=	float( HaloEffectLow ) + random.random ( ) * ( float( HaloEffecthigh ) - float( HaloEffectLow ) )
				BatchAssessment 						=	float( BatchAssessment ) + float( SenderSatisfactionValue ) * float( MessageWeight )
				NumMessagesProcessedThisAgentThisBatch	=	NumMessagesProcessedThisAgentThisBatch + 1
	BatchAssessment 									=	float( BatchAssessment ) / max( float( NumMessagesProcessedThisBatch ) , 1 ) # Finesse div/0 issue.

def AssessAdjustWorldViews ( ) :
#
# This function determines if Agents' Satisfaction histories and current TotalPersonalStorages mandates changes in WorldView, and makes this adjustment.
# Current test is to assess overall cumulative trend of SatisfactionValues and compare TotalPersonalStorage to last Allocation.
# Apply MemoryEffect and DenialEffect.
#
	import	copy
#
	global	SimTick , MemoryTicks , AgentData , Agent , MemoryTicks , ConsumptionBeliefsSpec , VariationToleranceThisTick , \
			PrintFlow
#
	if PrintFlow : print "      AssessAdjustWorldViews"
#
	for Agent in range ( 0 , len( AgentData ) ) :
#
		AgentID											=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		PersonalData									=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		WorldViewData									=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		SupplyBeliefIndex								=	copy.deepcopy( WorldViewData [ 0 ] )
		ConsumptionBeliefIndex							=	copy.deepcopy( WorldViewData [ 1 ] )
		PowerIndex										=	copy.deepcopy( WorldViewData [ 2 ] )
		AffinityData									=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		ThoughtLeaderData								=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		BiasesData										=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		NeedsData										=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		ClaimsData										=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
		AllocationsData									=	copy.deepcopy( AgentData [ Agent ] [ 8 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ Agent ] [ 9 ] )
		SatisfactionData								=	copy.deepcopy( AgentData [ Agent ] [ 10 ] )
#
	if SimTick >= MemoryTicks :
		SumSatisfactionValuesThisAgent					=	0
		for SatisfactionIndex in range ( 0 , len( SatisfactionData ) ) :
			MemoryEffectWeight							=	len( AllocationsData ) - SatisfactionIndex # Weight by recency.
			SumSatisfactionValuesThisAgent				=	SumSatisfactionValuesThisAgent + MemoryEffectWeight * SatisfactionData [ SatisfactionIndex ]
		LastAllocationThisAgent							=	AllocationsData [ len( AllocationsData ) - 1 ] [ 3 ]
#
		if SumSatisfactionValuesThisAgent < 0 and TotalPersonalStorage < LastAllocationThisAgent : # Downscale or flag for death in AdjustPopulation if no room to do so.
			if LastAllocationThisAgent - TotalPersonalStorage > VariationToleranceThisTick : # Apply DenialEffect.
				if ConsumptionBeliefIndex == len( ConsumptionBeliefsSpec ) : # No room to further downscale.
					AgentID								=	- AgentID # Flag for death in AdjustPopulation.
				else :
					SupplyBeliefIndex					=	SupplyBeliefIndex + 1
					ConsumptionBeliefIndex				=	ConsumptionBeliefIndex + 1
					PowerIndex							=	PowerIndex + 1
		if SumSatisfactionValuesThisAgent > 0 and TotalPersonalStorage > LastAllocationhisAgent : # Upscale if room to do so.
			if ConsumptionBeliefInderx > 0 :
				SupplyBeliefIndex						=	SupplyBeliefIndex - 1
				ConsumptionBeliefIndex					=	ConsumptionBeliefIndex - 1
				PowerIndex								=	PowerIndex - 1
#
		AgentData										.	insert( Agent , \
																[	AgentID , PersonalData , ( SupplyBeliefIndex , ConsumptionBeliefIndex , PowerIndex ) , AffinityData , \
																	ThoughtLeaderData , BiasesData , NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , \
																	SatisfactionData ] )
		AgentData										.	pop( Agent + 1 )

def AdjustPopulation ( ) :
#
# This function increases, decreases, or modifies the Agent population as indicated by various flags.
#
	import	copy
	import	random
#
	global	SimTick , AgentData , MaturityTick , MaxTick , NumberOfMalesByTick , NumberOfFemalesByTick , BirthRate , PregnancyDelayTicks , MaxPreganantTick , \
			AgentID , PersonalData, WorldViewData , AffinityData , ThoughtLeaderData , BiasesData , NeedsData , \
			ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData , \
			ThoughtLeaders , \
			PrintFlow
#
	if PrintFlow : print "      AdjustPopulation"
#
	RemoveList 											=	list ( )
	AddList 											=	list ( )
	NumberOfPregnanciesRequiredThisTick 				=	int( round( float( len( AgentData ) ) * float( BirthRate ) , 0 ) )
	NumberOfPregnanciesAssignedThisTick 				=	0
	for Agent in range ( 0, len ( AgentData ) ) :
		AgentID											=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		PersonalData									=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		Age												=	copy.deepcopy( PersonalData [ 0 ] )
		Gender											=	copy.deepcopy( PersonalData [ 1 ] )
		PregnancyStatus									=	copy.deepcopy( PersonalData [ 2 ] )
		WorldViewData									=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		AffinityData									=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		ThoughtLeaderData								=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		BiasesData										=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		NeedsData										=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		ClaimsData										=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
		AllocationsData									=	copy.deepcopy( AgentData [ Agent ] [ 8 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ Agent ] [ 9 ] )
		SatisfactionData								=	copy.deepcopy( AgentData [ Agent ] [ 10 ] )
# Age all Agents.
		Age												=	Age + 1
		if PregnancyStatus < 0 :
			PregnancyStatus								=	PregnancyStatus + 1
		if Age == MaturityTick :
			ThoughtLeaderData 							=	"No"
			if ThoughtLeaderFraction > random.random( ) :
				ThoughtLeaderData						=	"Yes"
				ThoughtLeaders							.	append( AgentID )
# Birth newborns.
		if PregnancyStatus == 1 :
			AddList										.	append ( (	Agent , AgentID , PersonalData , WorldViewData , AffinityData , ThoughtLeaderData , \
																		BiasesData , NeedsData , ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionData ) )
# Make some Agents pregnant.
		if NumberOfPregnanciesAssignedThisTick <= NumberOfPregnanciesRequiredThisTick :
			if Gender == "Female" and MaxPregnantTick >= Age >= MaturityTick and PregnancyStatus == 0 :
				if random.random ( ) <= BirthRate : 
					PregnancyStatus 					=	1
				 	NumberOfPregnanciesAssignedThisTick =	NumberOfPregnanciesAssignedThisTick + 1
# Prepare to remove some Agents.
		if random.random ( ) <= DeathRate : # Death by statistics.
			RemoveList									.	append ( Agent ) 
		if AgentID < 0 : # Death by persistent Needs shortfall.
			RemoveList									.	append ( Agent )
		if Age > MaxTick : # Death by old age.
			RemoveList									.	append ( Agent)
#
	for RemoveIndex in range (  0 , len ( RemoveList ) ) :
		ReverseIndex									=	len( RemoveList ) - RemoveIndex - 1 # Avoid incorrect removals by starting at highest index and working down.
		if ThoughtLeaderData == "Yes" :
			for ThoughtLeaderIndex in range ( 0 , len( ThoughtLeaders ) ) :
				if ThoughtLeaders [ ThoughtLeaderIndex ] == AgentID :
					ThoughtLeaders						.	pop( ThoughtLeaderIndex )
		AgentData										.	pop( RemoveList [ ReverseIndex ] )
#
	for AddIndex in range ( 0 , len ( AddList ) ) :
# Prepare to modify Mother's data.
		MothersAge										=	Age
		MothersNewPregnancyStatus						=	-PregnancyDelayTicks
		MothersNewPersonalData							=	( MothersAge , "Female" , MothersNewPregnancyStatus )				
		MothersNewData									=	[ 	AddList [ AddIndex ] [ 1 ] , MothersNewPersonalData , AddList [ AddIndex ] [ 3 ] , AddList [ AddIndex ] [ 4 ] , \
																AddList [ AddIndex ] [ 5 ] , AddList [ AddIndex ] [ 6 ] , AddList [ AddIndex ] [ 7 ] , AddList [ AddIndex ] [ 8 ] , \
																AddList [ AddIndex ] [ 9 ] , AddList [ AddIndex ] [ 10 ] , AddList [ AddIndex ] [ 11 ] 	]
		MothersAgentDataIndex							=	AddList [ AddIndex ] [ 0 ]
		AgentData										.	insert( MothersAgentDataIndex , MothersNewData )
		AgentData										.	pop( MothersAgentDataIndex + 1 )
# Prepare newborn's data for CreateNewAgent ( ).
		AgentID											=	len( AgentData ) + 1
		NewBornsAge										=	0
		NewBornsGender 									=	"Female" # Default.
		NewBornsPregnancyStatus							=	0
		if random.random  ( ) > float( NumberOfMalesByTick [ MothersAge ] ) / float( NumberOfFemalesByTick [ MothersAge ] ) :
			NewBornsGender								=	"Male"
			PregnancyStatus								=	"Never"
		PersonalData									=	( NewBornsAge, NewBornsGender , NewBornsPregnancyStatus )
		WorldViewData									=	AddList [ AddIndex ] [ 3 ]
		AffinityData									=	AddList [ AddIndex ] [ 4 ]
		ThoughtLeaderData								=	AddList [ AddIndex ] [ 5 ]
		BiasesData										=	AddList [ AddIndex ] [ 6 ]
		NeedsData										=	AddList [ AddIndex ] [ 7 ]
		ClaimesData										=	AddList [ AddIndex ] [ 8 ]
		AllocationsData									=	AddList [ AddIndex ] [ 9 ]
		TotalPersonalStorage							=	AddList [ AddIndex ] [ 10 ]
		SatisfactionData								=	AddList [ AddIndex ] [ 11 ]
		CreateNewAgent ( )
#	print "         Pregnancies, Deaths" , NumberOfPregnanciesAssignedThisTick , len( RemoveList )

def DisplayWorld ( ) :
#
# This function displays the status of EnergyWorld at the end of each Simulation Tick.
#
	global	SimTick , AgentData , \
			PrintFlow
#
	if PrintFlow : print "      DisplayWorld"
#
	pass

Main ( )
