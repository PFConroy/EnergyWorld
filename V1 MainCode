def Main ( ) :
	global	NumSimulations , NumTicksEachSimulation , SimTick , \
			TimeError , SimError , EnergyError , PopulationError , \
			PrintFlow
#
	print "Start"
	InitializeMonitoring ( )
	CharacterizeTime ( )
	if not TimeError :
		CharacterizeSimulations ( )
		if not SimError :
			CharacterizeEnergy ( )
			if not EnergyError:
				for SimulationID in range ( 0 , NumSimulations ) :
					CharacterizePopulation ( )
					if not PopulationError :
						GenerateAgents ( )
						for SimTick in range ( 0 , NumTicksEachSimulation ) :
#							RandomizeClaimsAndAllocationsOrder ( )
							CalculateAgentsClaims ( )
							AllocateEnergyToAgents ( )
#							InterAgentDiscussions ( )
#							AssessWorldViews ( )
#							AdjustWorldViews ( )
#							AdjustPopulation ( )
#							DisplayWorld ( )
	print "End"

def InitializeMonitoring ( ) :
#
# This function sets error flags and diagnostic indicators.
#
	global	TimeError , EnergyError , SimError , AgeGenderError , BirthsDeathsError , BDIPError , BiasesError , AffinitiesError , NeedsError , PopulationError , \
			PrintFlow
# Get/set monitor/control flags.
	PrintFlow 					= True
	TimeError					= False
	EnergyError					= False
	SimError					= False
	AgeGenderError				= False
	BirthsDeathsError			= False
	BDIPError					= False
	BiasesError					= False
	AffinitiesError				= False
	NeedsError					= False
	PopulationError				= False
#
	if PrintFlow : print "   InitiatlizeMonitoring"

def CharacterizeTime ( ) :
#
# This function provides all parameters basic to all time-focused data and processes.
#
	global 	MemoryTicks , NumMessagesPerTick , NumMessagesPerBatch , \
			TimeError , \
			PrintFlow
#
	if PrintFlow: print "   CharacterizeTime"
# Get/set data.
	MemoryTicks 			= 3
	NumMessagesPerTick 		= 100000
	NumMessagesPerBatch 	= 10
#
# Verify/validate data.
#
	TimeError = False
	if	( not ( isinstance( MemoryTicks ,			int ) and MemoryTicks			>= 0 ) ) 	or \
		( not ( isinstance( NumMessagesPerTick , 	int ) and NumMessagesPerTick 	>= 0 ) )	or \
		( not ( isinstance( NumMessagesPerBatch , 	int ) and NumMessagesPerBatch 	>= 0 ) ) 	: TimeError = True
	if TimeError : print "WARNING: Error in Time spec. Simulation will halt."

def CharacterizeSimulations ( ) :
#
# This function will be enhanced to provide for suites of simulations, eg Monte Carlo. At this point it specifies that a single simulation scenario should be run.
#
	global 	NumSimulations , NumTicksEachSimulation , \
			SimError , \
			PrintFlow
#
	if PrintFlow: print "   CharacterizeSimulations"
#
	SimError 				= False
	NumSimulations 			= 1
	NumTicksEachSimulation	= 10
#
	if	( not ( isinstance( NumSimulations ,			int ) and NumSimulations			> 0 ) ) 	or \
		( not ( isinstance( NumTicksEachSimulation , 	int ) and NumTicksEachSimulation 	> 0 ) )		: SimError = True
	if SimError : print "WARNING: Error in Simulation spec. Simulation will halt."
	
def CharacterizeEnergy ( ) :
#
# This function develops a complete schedule of energy to be supplied to EnergyWorld's population.
#
# Takes as input (Tick,Factor) tuples..
# All values must be numbers > 0; Factor value either integer or float.
# Tuples must have progressively increasing Ticks with progressively increasing Cycles.
# CalculateAgentClaims will fill out EnergySupply to better support CalculateClaims, .
#
	global 	EnergySupplySpec , EnergySupplyFactors , NumTicksEachSimulation , InitialCommunityStorageMultiple , CommunityStorageDiverstionFactor , \
			EnergyError , \
			ParameterizationError
#
	if PrintFlow: print "   CharacterizeEnergy"
# Get/set data.
	EnergySupplySpec = list ( )
	EnergySupplySpec = [ \
		( 0 , 1.0 ) , 	\
		( 4 , 0.2 ) , 	\
		( 8 , 0.1 )  	]
	InitialCommunityStorageMultiple		=	1.0 	# Will be applied to first Tick's energy supply for first Tick after History Creation period.
	CommunityStorageDiverstionFactor	=	0.05 	# To be diverted from each Tick's energy allocation after .
#
# Verify/validate data.
#
	for SpecIndex in range ( 0 , len ( EnergySupplySpec ) ) :
		if	( not ( isinstance( EnergySupplySpec [ SpecIndex ] [ 0 ] , 	int )	and 	EnergySupplySpec [ SpecIndex ] [ 0 ] 	>= 	0 	) )		or \
			( not ( isinstance( EnergySupplySpec [ SpecIndex ] [ 1 ] , 	float ) and 	EnergySupplySpec [ SpecIndex ] [ 1 ] 	>= 	0.0 ) )		: EnergyError = True
	if		( not ( isinstance( InitialCommunityStorageMultiple , 		float )	and 	InitialCommunityStorageMultiple 		>= 	0.0	) )		or \
			( not ( isinstance( CommunityStorageDiverstionFactor ,		float )	and 	CommunityStorageDiverstionFactor		>= 	0.0	) )		: EnergyError = True
	if EnergyError : print "WARNING: Error in Energy spec. The simulation will hatl."
#
	EnergySupplyFactors 				=	list( )
	for SpecIndex in range ( 0 , len( EnergySupplySpec ) ) :
		Factor 							=	EnergySupplySpec [ SpecIndex ] [ 1 ]
		SameFactorTickLow 				=	EnergySupplySpec [ SpecIndex ] [ 0 ]
		SameFactorTickHigh 				=	NumTicksEachSimulation
		if SpecIndex < len( EnergySupplySpec ) - 1 :
			 SameFactorTickHigh 		=	EnergySupplySpec [ SpecIndex + 1 ] [ 0 ]
		for TickIndex in range ( SameFactorTickLow , SameFactorTickHigh ) :
			EnergySupplyFactors 		.	append( Factor )
	print EnergySupplyFactors

def CharacterizePopulation ( ) :
#
# This function acquires age/gender, births/deaths, beliefs/desires/intentions/powers, affinities, needs, and biases data for generating EnergyWorld's starting population.
#
# The commented-out code block immediately below is a suggestion for how to acquire data from a file. It has not been tested and may not be correct.
# Other methods for acquiring data, e.g. from other EnergyWorld functions and from the user in real time, have not yet been explored.
#
	global	PopulationError , \
			PrintFlow
#
	if PrintFlow : print "   CharacterizePopulation"
#
	if not ( TimeError or EnergyError or SimError ) :
		PopulationError = True
		GetAndCheckAgeGenderData ( )
		if not AgeGenderError :
			GetAndCheckBirthsDeathsData ( )
			if not BirthsDeathsError :
				GetAndCheckBeliefsDesiresIntentionsPowersData ( )
				if not BDIPError :
					GetAndCheckBiasesData ( )
					if not BiasesError :
						GetAndCheckAffinitiesData ( )
						if not AffinitiesError :
							GetAndCheckNeedsData ( )
							PopulationError = False
	if PopulationError :
		print "WARNING: Error in Population spec. Simulation will halt."

def GetAndCheckAgeGenderData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	ApproximateStartingPopulation is used to generate EnergyWorld's starting population as multiples of the population defined by NominalPopulationSpec.
#	(ActualStartingPopulation will be the multiple of len(WorldViewCombinations) that is greater than or equal to ApproximateStartingPosition.)
#	MaxTick is the age after which Agents will be deleted from EnergyWorld.
#	RetirementTick is used in making some energy claims in CalculateAgentsClaims.
#	MaturityTick is the age at Agents begin to make assessments and adjustments to their worldviews.
#	NominalPopulationSpec is the basis for EnergyWorld's starting population. It specifies the relative number of males and females for each age from 0 through MaxAge.
#
	global	ApproximateStartingPopulationSize , AbsoluteMaximumPopulationSize , \
			MaxTick , RetirementTick , MaturityTick , MalePopulationFraction , PopulationCountBasis , NominalPopulationSpec , \
			AgeGenderError , \
			PrintFlow
#
	import math
#
	if PrintFlow: print "      AgeGenderData"
# Get/set data.
	ApproximateStartingPopulationSize 	= 10 # Almost ignored in favor of WorldView, AgeGender and NominalPopulation factors.
	AbsoluteMaximumPopulationSize		= 160000
#	print "         PopulationGuide" , ApproximateStartingPopulationSize
	MaxTick								= 99
	RetirementTick 						= 65
	MaturityTick 						= 18
	NominalPopulationSpec 				= list ( ) # From http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo10a-eng.htm
	PopulationCountBasis 				= 0.2 * 0.01 # StatsCan data shows total % for 5-year periods.
	NominalPopulationSpec = [ \
		( 0  , 5.6 , 5.3 ) , ( 1  , 5.6 , 5.3 ) , ( 2  , 5.6 , 5.3 ) , ( 3  , 5.6 , 5.3 ) , ( 4  , 5.6 , 5.3 ) , \
		( 5  , 5.5 , 5.2 ) , ( 6  , 5.5 , 5.2 ) , ( 7  , 5.5 , 5.2 ) , ( 8  , 5.5 , 5.2 ) , ( 9  , 5.5 , 5.2 ) , \
		( 10 , 5.5 , 5.1 ) , ( 11 , 5.5 , 5.1 ) , ( 12 , 5.5 , 5.1 ) , ( 13 , 5.5 , 5.1 ) , ( 14 , 5.5 , 5.1 ) , \
		( 15 , 6.4 , 6.0 ) , ( 16 , 6.4 , 6.0 ) , ( 17 , 6.4 , 6.0 ) , ( 18 , 6.4 , 6.0 ) , ( 19 , 6.4 , 6.0 ) , \
		( 20 , 7.1 , 6.8 ) , ( 21 , 7.1 , 6.8 ) , ( 22 , 7.1 , 6.8 ) , ( 23 , 7.1 , 6.8 ) , ( 24 , 1.1 , 6.8 ) , \
		( 25 , 6.9 , 6.8 ) , ( 26 , 6.9 , 6.8 ) , ( 27 , 6.9 , 6.8 ) , ( 28 , 6.9 , 6.8 ) , ( 29 , 6.9 , 6.8 ) , \
		( 30 , 7.0 , 6.9 ) , ( 31 , 7.0 , 6.9 ) , ( 32 , 7.0 , 6.9 ) , ( 33 , 7.0 , 6.9 ) , ( 34 , 7.0 , 6.9 ) , \
		( 35 , 6.7 , 6.6 ) , ( 36 , 6.7 , 6.6 ) , ( 37 , 6.7 , 6.6 ) , ( 38 , 6.7 , 6.6 ) , ( 39 , 6.7 , 6.6 ) , \
		( 40 , 6.8 , 6.7 ) , ( 41 , 6.8 , 6.7 ) , ( 42 , 6.8 , 6.7 ) , ( 43 , 6.8 , 6.7 ) , ( 44 , 6.8 , 6.7 ) , \
		( 45 , 7.4 , 7.2 ) , ( 46 , 7.4 , 7.2 ) , ( 47 , 7.4 , 7.2 ) , ( 48 , 7.4 , 7.2 ) , ( 49 , 7.4 , 7.2 ) , \
		( 50 , 7.9 , 7.7 ) , ( 51 , 7.9 , 7.7 ) , ( 52 , 7.9 , 7.7 ) , ( 53 , 7.9 , 7.7 ) , ( 54 , 7.9 , 7.7 ) , \
		( 55 , 7.2 , 7.1 ) , ( 56 , 7.2 , 7.1 ) , ( 57 , 7.2 , 7.1 ) , ( 58 , 7.2 , 7.1 ) , ( 59 , 7.2 , 7.1 ) , \
		( 60 , 6.0 , 6.0 ) , ( 61 , 6.0 , 6.0 ) , ( 62 , 6.0 , 6.0 ) , ( 63 , 6.0 , 6.0 ) , ( 64 , 6.0 , 6.0 ) , \
		( 65 , 4.9 , 5.1 ) , ( 66 , 4.9 , 5.1 ) , ( 67 , 4.9 , 5.1 ) , ( 68 , 4.9 , 5.1 ) , ( 69 , 4.9 , 5.1 ) , \
		( 70 , 3.4 , 3.7 ) , ( 71 , 3.4 , 3.7 ) , ( 72 , 3.4 , 3.7 ) , ( 73 , 3.4 , 3.7 ) , ( 74 , 3.4 , 3.7 ) , \
		( 75 , 2.5 , 2.9 ) , ( 76 , 2.5 , 2.9 ) , ( 77 , 2.5 , 2.9 ) , ( 78 , 2.5 , 2.9 ) , ( 79 , 2.5 , 2.9 ) , \
		( 80 , 1.8 , 2.4 ) , ( 81 , 1.8 , 2.4 ) , ( 82 , 1.8 , 2.4 ) , ( 83 , 1.8 , 2.4 ) , ( 84 , 1.8 , 2.4 ) , \
		( 85 , 0.9 , 1.6 ) , ( 86 , 0.9 , 1.6 ) , ( 87 , 0.9 , 1.6 ) , ( 88 , 0.9 , 1.6 ) , ( 89 , 0.9 , 1.6 ) , \
		( 90 , 0.4 , 1.0 ) , ( 91 , 0.4 , 1.0 ) , ( 92 , 0.4 , 1.0 ) , ( 93 , 0.4 , 1.0 ) , ( 94 , 0.4 , 1.0 ) , \
		( 95 , 0.4 , 1.0 ) , ( 96 , 0.4 , 1.0 ) , ( 97 , 0.4 , 1.0 ) , ( 98 , 0.4 , 1.0 ) , ( 99 , 0.4 , 1.0 )   ]
#
	NumMales 				= 0
	NumFemales 				= 0
	NumAll					= 0
	for PopIndex in range( 0 , len( NominalPopulationSpec ) ) :
		NumMales 			= NumMales + NominalPopulationSpec [ PopIndex ] [ 1 ]
		NumFemales 			= NumFemales + NominalPopulationSpec [ PopIndex ] [ 2 ]
		NumAll				= NumAll + NominalPopulationSpec [ PopIndex ] [ 1 ] + NominalPopulationSpec [ PopIndex ] [ 2 ]
	MalePopulationFraction 	= float( NumMales ) / float( NumAll ) # StatsCan average for past 5 years = 0.495.
#
# Verify/validate data.
#
	AgeGenderError = False
	if	( not ( isinstance( ApproximateStartingPopulationSize , 			int ) 	and ApproximateStartingPopulationSize 			> 0 ) ) 	or \
	   	( not ( isinstance( MaxTick , 										int )	and MaxTick 									> 0 ) ) 	or \
		( not ( isinstance( RetirementTick , 								int )	and RetirementTick								> 0 ) ) 	or \
		( not ( isinstance( MaturityTick , 									int )	and MaturityTick								> 0 ) ) 	or \
	   	( not ( MaturityTick <= RetirementTick <= MaxTick																				) ) 	: AgeGenderError = True
	SequentialTickComparator = NominalPopulationSpec [ 0 ] [ 0 ] - 1
	for SpecIndex in range( 0, len( NominalPopulationSpec ) ) :
		if	( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 0 ] , int )	 and NominalPopulationSpec [ SpecIndex ] [ 0 ] >= 0	) )		or \
	   		( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 1 ] , float )	 and NominalPopulationSpec [ SpecIndex ] [ 1 ] >= 0.0 ) )	or \
	   		( not ( isinstance( NominalPopulationSpec [ SpecIndex ] [ 2 ] , float )	 and NominalPopulationSpec [ SpecIndex ] [ 2 ] >= 0.0 ) )	or \
	   		( not ( NominalPopulationSpec [ SpecIndex ] [ 0 ] == SequentialTickComparator + 1 ) )												: AgeGenderError = True
		SequentialTickComparator = NominalPopulationSpec [ SpecIndex ] [ 0 ]
	if AgeGenderError : print "WARNING: Error in AgeGender spec. Simulation will halt."
	
def GetAndCheckBirthsDeathsData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	GestationTicks is the number of Ticks a normal pregnancy lasts.
#	PregnancyDelayTicks is the number of Ticks that an Agent must wait after giving birth to become pregnant.
#	MaxPregnantTick is the maximum age that an Agent can become pregnant.
#	BirthRate is derived from
#	http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo02a-eng.htm (population) and # http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/demo04a-eng.htm (births)
#		Statistics Canada Births: 2009/10 379,373; 2010/11 376,951; 2011/12 378,752; 2012/13 383,822
#		Statistics Canada Population: 2009 33,628,600; 2010 34,005,300; 2011 34,342,800; 2012 34,754,300
#	DeathSpec is taken from http://www.statcan.gc.ca/tables-tableaux/sum-som/l01/cst01/health30a-eng.htm (average of rates 2007-2011).
#	DeathRateBasis is the denomintor against which actual deaths are calculated to arrive at a percentage.
#
# Speciy and check all birth-related data. When integrated, this data should be acquired from a file or the user in real time.
#
	global	GestationTicks , PregnancyDelayTicks , MaxPregnantTick , BirthRate , DeathRate , \
			BirthsDeathsError , \
			PrintFlow
#
	if PrintFlow: print "      BirthsDeathData"
# Get/set data.
	GestationTicks 		= 9
	PregnancyDelayTicks = 18
	MaxPregnantTick		= 65
	BirthRate 			= round( ( float( 379373 ) / float( 33628600 ) + float( 376951 ) / float( 34005300 ) + float( 378752 ) / float( 34342800 ) + \
							float( 383822 ) / float( 34754300 ) ) / 4.0 , 4 )
	DeathRate			= round( ( float( 44 ) + float( 47 ) + float( 47 ) + float( 46 ) + float( 48 ) ) / 50000 , 4 ) # StatsCan average for past 5 years.
#
# Verify/validate data.
#
	if	( not ( isinstance( GestationTicks , 		int ) 	and GestationTicks 		> 0 ) ) or \
		( not ( isinstance( PregnancyDelayTicks , 	int ) 	and PregnancyDelayTicks > 0 ) ) or \
		( not ( isinstance( MaxPregnantTick , 		int ) 	and MaxPregnantTick 	> 0 ) ) or \
		( not ( isinstance( BirthRate ,				float ) and BirthRate 			> 0 ) ) or \
		( not ( isinstance( DeathRate ,				float ) and DeathRate	 		> 0 ) ) : BirthsDeathsError = True
	if BirthsDeathsError : print "WARNING: Error in BirthsDeaths spec. Simulation will halt."
	
def GetAndCheckBeliefsDesiresIntentionsPowersData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
#
# Notes:
#	At present, Desires and Intentions are coupled to ConsumptionBeliefs, and ConsumptionBeliefs and Powers are the dimensions of WorldView options.
#	SupplyBeliefsSpec defines the levels of belief that an Agent has about the supply of energy; currently this is a descriptive, not operational variable.
#	ConsumptionBeliefsSpec defines the level of belief that an Agent has about their deservedness to consume energy; this is a primary operational variable.
#	DesiresSpec defines the goals associated with the above Consumption Belief options.
#	IntentionsSpec defines the Claims that Agents will make; currently these are hard-coded (the intent is to enable algorithmic specification).
#	PowersSpec defines the level of access to Energy Allocations. Agents' claims are met in order of their Power (same-Power Agents are randomized).
#
	global	SupplyBeliefsSpec , ConsumptionBeliefsSpec , DesiresSpec , IntentionsSpec , FullClaimFactors , RetirementClaimFactors , PowersSpec , \
			TotalNominalPopulation , TotalNominalConsumption , \
			BDIPError , \
			PrintFlow
#
	if PrintFlow: print "      BDIPData"
# Get/set data.
	SupplyBeliefsSpec = list ( )
	SupplyBeliefsSpec = [ \
		( "Ignore" ,						True			) ,	\
		( "No limits known" , 				1				) ,	\
		( "Unlimited in long term" , 		2				) ,	\
		( "Limited in short term" , 		3				) ,	\
		( "Maxed Out" , 					2				) ,	\
		( "Limited now" , 					1				)	]
	ConsumptionBeliefsSpec = list ( )
	ConsumptionBeliefsSpec = [ \
		( "Ignore" ,						False			) ,	\
		( "Luxurious" , 					1 ,		5000	) ,	\
		( "Comfortable" , 					1 ,		500		) ,	\
		( "Basic" , 						3 ,		50		) ,	\
		( "Subsistence, all needs" ,  		2 , 	5		) ,	\
		( "Subsistence, physical needs" , 	1 , 	1		) 	]
	PowersSpec = list ( )
	PowersSpec = [ \
		( "Ignore" ,						False			) ,	\
		( "Infinite" , 						1				) , \
		( "High" , 							2				) ,	\
		( "Medium" , 						3				) , \
		( "Low" , 							2				) ,	\
		( "Zero" , 							1				) 	]
#
	DesiresSpec = list ( )
	DesiresSpec = [ \
		( "Rapid securing of an exceptional lifestyle until death" ) , 		\
		( "Realistic lifestyle with secure retirement at current level" ) , \
		( "Avoid falling to subsistence level; minimal retirement" ) , 		\
		( "Minimal lifestyle capable of supporting self-actualization" ) , 	\
		( "Minimal healthy physical survival" )								]
#
	FullClaimFactors = list( )
	FullClaimFactors = [ \
		( 1.0 , 1.0 , 1.0 , 1.5 , 1.2 ) , 	\
		( 0.5 , 0.2 , 0.1 , 0.0 , 0.0 ) , 	\
		( 0.1 , 0.1 , 0.1 , 0.0 , 0.0 ) 	]
	RetirementClaimFactors = list( )
	RetirementClaimFactors = [ \
		( 1.0 , 1.0 , 1.0 , 1.2 , 1.1 ) , 	\
		( 0.2 , 0.2 , 0.0 , 0.0 , 0.0 ) , 	\
		( 0.1 , 0.0 , 0.0 , 0.0 , 0.0 ) 	]
	IntentionsSpec = list( )
	IntentionsSpec = [ FullClaimFactors , RetirementClaimFactors ]
#
	TotalNominalPopulation				=	0
	TotalNominalConsumption				=	0
	for BeliefIndex in range ( 1 , len( ConsumptionBeliefsSpec ) ) :
		TotalNominalPopulation			=	TotalNominalPopulation + ConsumptionBeliefsSpec [ BeliefIndex ] [ 1 ]
		TotalNominalConsumption			=	TotalNominalConsumption + ConsumptionBeliefsSpec [ BeliefIndex ] [ 1 ] * ConsumptionBeliefsSpec [ BeliefIndex ] [ 2 ]
#
# Verify/validata data.
#
	if 	( not ( isinstance( SupplyBeliefsSpec [ 0 ] [ 1 ] , 						bool ) 															) )		or \
		( not ( isinstance( ConsumptionBeliefsSpec [ 0 ] [ 1 ] ,					bool ) 															) )		or \
		( not ( isinstance( PowersSpec [ 0 ] [ 1 ] , 								bool ) 															) )		: BDIPError = True
	for Index in range ( 1 , len ( SupplyBeliefsSpec ) ) :
		if	( not ( isinstance( SupplyBeliefsSpec [ Index ] [ 1 ] ,					int ) 	and		SupplyBeliefsSpec [ Index ] [ 1 ]			>= 0 ) )	or \
	   		( not ( isinstance( ConsumptionBeliefsSpec [ Index ] [ 1 ] ,			int ) 	and		ConsumptionBeliefsSpec [ Index ] [ 1 ]		>= 0 ) ) 	or \
	   		( not ( isinstance( ConsumptionBeliefsSpec [ Index ] [ 2 ] ,			int ) 	and		ConsumptionBeliefsSpec [ Index ] [ 2 ]		>= 0 ) )	or \
	   		( not ( isinstance( PowersSpec [ Index ] [ 1 ] ,						int ) 	and		PowersSpec [ Index ] [ 1 ]					>= 0 ) )	: BDIPError = True
	for Index1 in range ( 0 , len( FullClaimFactors ) ) :
		for Index2 in range ( 0 , 5 ) :
			 if ( not ( isinstance( FullClaimFactors [ Index1 ] [ Index2 ] , 		float ) and 	FullClaimFactors [ Index1 ] [ Index2 ] 		>= 0 ) )	or \
			 	( not ( isinstance( RetirementClaimFactors [ Index1 ] [ Index2 ] , 	float ) and 	RetirementClaimFactors [ Index1 ] [ Index2 ]>= 0 ) )	: BDIPError = True

	if BDIPError : print "WARNING: Error in BeliefsDesiresIntentionsPowers data values. Simuluation will halt."
	
def GetAndCheckBiasesData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	All Biases data must be float values between 0.0 and 1.0 inclusive. The Low and High values form the range for randomization of the actual effect applied.
#	RiskAcceptanceEffect incorporates a number of Cognitive Biases that collectively represent the tendency to be risk tolerant when one can gain something of value.
#	RiskAvoidanceEffect incorporates a number of Cognitive Biases that collectively represent the tendency to be risk averse when one can lose something of value.
#	BelongingnessEffect incorporates a number of Cognitive Biases that collectively represent the tendency to make oneself more like a defined group than otherwise.
#	HaloEffect incorporates a number of Cognitive Biases that collectively represent the tendency to ascribe more authority to certain individuals than others.
#	DenialEffect iincorporates a number of Cognitive Biases that collectively represent the tendency to discount the messages one receives.
#
	global	RiskAcceptanceEffectLow , RiskAcceptanceEffectHigh , RiskAvoidanceEffectLow , RiskAvoidanceEffectHigh , BelongingnessEffectLow , BelongingnessEffectHigh , \
			HaloEffectLow , HaloEffectHigh , MemoryEffectLow , MemoryEffectHigh , DenialEffectLow , DenialEffectHigh , \
			BiasesError , \
			PrintFlow
#
	if PrintFlow: print "      BiasesData"
# Get/set data.
	RiskAcceptanceEffectLow = 	0.1
	RiskAcceptanceEffectHigh = 	0.5
	RiskAvoidanceEffectLow = 		0.1
	RiskAvoidanceEffectHigh =  		0.3
	BelongingnessEffectLow = 	0.2
	BelongingnessEffectHigh = 	0.4
	HaloEffectLow = 				0.1
	HaloEffectHigh =  				0.5
	MemoryEffectLow = 			0.3
	MemoryEffectHigh = 			0.6
	DenialEffectLow = 				0.1
	DenialEffectHigh = 				0.3
#
# Verify/validata data.
#
	if	( not ( isinstance( RiskAcceptanceEffectLow ,	float ) and 1.0 >= RiskAcceptanceEffectHigh 	>= 0 ) ) or \
	   	( not ( isinstance( RiskAvoidanceEffectLow , 	float ) and 1.0 >= RiskAvoidanceEffectHigh 		>= 0 ) ) or \
		( not ( isinstance( BelongingnessEffectLow , 	float ) and 1.0 >= BelongingnessEffectHigh		>= 0 ) ) or \
		( not ( isinstance( HaloEffectLow , 			float ) and 1.0 >= HaloEffectHigh 				>= 0 ) ) or \
		( not ( isinstance( MemoryEffectLow , 			float ) and 1.0 >= MemoryEffectHigh 			>= 0 ) ) or \
		( not ( isinstance( DenialEffectLow , 			float ) and 1.0 >= DenialEffectHigh 			>= 0 ) ) : BiasesError = True
	if BiasesError : print "WARNING: Error in Biases data values. Simulation will halt."
	
def GetAndCheckAffinitiesData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	ThoughtLeaderFraction is the % of all Affinity Groups that are thought leaders, whose input to inter-agent discussions is weighted more highly than others.
#	AffinitiesSpec is a list of tuples of the form (AffinityGroupDescription,ConsumptionBeliefIndex); normally, only one ConsumptionBelief would attach to a given AffinityGroup.
#
	global	ThoughtLeaderFraction , AffinitiesSpec , \
			AffinitiesError , \
			PrintFlow
#
	if PrintFlow: print "      AffinitiesData"
# Get/set data.
	ThoughtLeaderFraction 		= 0.1
	AffinitiesSpec 				= list( )
	AffinitiesSpec 				= [ ( "Basic is equitable" , 2 ) , ( "Out for number 1" , 0 ) , ( "Just getting by" , 3 ) , ( "In trouble" , 4 ) , ( "Life is good" , 1 ) ]
# Verify/validate data.
	if	( not ( isinstance( ThoughtLeaderFraction , float ) and 0.0 <= ThoughtLeaderFraction <= 1.0 ) ) : AffinitiesError = True
	if AffinitiesError : print "WARNING: Error in Affinites spec. Simulation will halt."
	
def GetAndCheckNeedsData ( ) :
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes:
#	Needs data reflect Maslow's Hierarchy of Needs; values are in energy units.
#
	global	PhysiologicalNeedsLow , PhysiologicalNeedsHigh , SafetyNeedsLow , SafetyNeedsHigh , AttachmentNeedsLow , AttachmentNeedsHigh , FullClaimsFactors , \
			EsteemNeedsLow , EsteemNeedsHigh , ActualizationNeedsLow , ActualizationNeedsHigh , InitialWealthFactor , NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh , \
			NeedsError , \
			PrintFlow
#
	if PrintFlow: print "      NeedsData"
# Get/set data.
	PhysiologicalNeedsLow	= 75
	PhysiologicalNeedsHigh	= 100
	SafetyNeedsLow				= 50
	SafetyNeedsHigh				= 75
	AttachmentNeedsLow		= 15
	AttachmentNeedsHigh		= 20
	EsteemNeedsLow				= 10
	EsteemNeedsHigh				= 15
	ActualizationNeedsLow	= 1
	ActualizationNeedsHigh	= 5
	NeedsNotMetToleranceLow		= 1
	NeedsNotMetToleranceHigh	= 3
#
	InitialWealthFactor		= 1.0
#
# Verify/validate data. 
#
	if	( not ( isinstance( PhysiologicalNeedsLow ,		int ) and PhysiologicalNeedsLow			>= 0 ) ) or \
		( not ( isinstance( PhysiologicalNeedsHigh ,	int ) and PhysiologicalNeedsHigh		>= 0 ) ) or \
		( not ( isinstance( SafetyNeedsLow ,			int ) and SafetyNeedsLow				>= 0 ) ) or \
		( not ( isinstance( SafetyNeedsHigh ,			int ) and SafetyNeedsHigh				>= 0 ) ) or \
		( not ( isinstance( AttachmentNeedsLow ,		int ) and AttachmentNeedsLow			>= 0 ) ) or \
		( not ( isinstance( AttachmentNeedsHigh ,		int ) and AttachmentNeedsHigh			>= 0 ) ) or \
		( not ( isinstance( EsteemNeedsLow ,			int ) and EsteemNeedsLow				>= 0 ) ) or \
		( not ( isinstance( EsteemNeedsHigh ,			int ) and EsteemNeedsHigh				>= 0 ) ) or \
		( not ( isinstance( ActualizationNeedsLow ,		int ) and ActualizationNeedsLow 		>= 0 ) ) or \
		( not ( isinstance( ActualizationNeedsHigh ,	int ) and ActualizationNeedsHigh 		>= 0 ) ) or \
		( not ( isinstance( NeedsNotMetToleranceLow , 	int ) and NeedsNotMetToleranceLow		>= 0 ) ) or \
		( not ( isinstance( NeedsNotMetToleranceHigh , 	int ) and NeedsNotMetToleranceHigh		>= 0 ) ) or \
		( not ( isinstance( InitialWealthFactor , 		float ) and InitialWealthFactor			>= 0.0 ) ) : NeedsError = True
	if NeedsError : print "WARNING: Error in Needs spec. Simulation will halt."

def GenerateAgents ( ) :
#
# This function generates the initial set of Agents for the current simulation.
#
# Hand-crafted data is supplied for test purposes. Replace with file input, other function outputs, or real-time user input when code is stabilized.
# Notes: (ALgorithm under review)
#	The size of the generated population is calculated as the smallest multiple of len(WorldViewCombinations) greater than or equal to ApproximateStartingPopulation,
#	rounded up to the next multiple of len(NominalPopulation in orderto support allocation to ages and genders reflective of NominalPopulation.
#
	import math
	import random
#
	global	AgentData , PowersSpec , PowerBlockData , \
			NominalPopulationSpec , StartingPopulationSize , NumberOfMalesByTick , NumberOfFemalesByTick , WorldViewCombinations , AffinitiesSpec , \
			RiskAcceptanceEffectLow , RiskAcceptanceEffectHigh , RiskAvoidanceEffectLow , RiskAvoidanceEffectHigh , BelongingnessEffectLow , BelongingnessEffectHigh , \
			HaloEffectLow , HaloEffectHigh , MemoryEffectLow , MemoryEffectHigh , DenialEffectLow , DenialEffectHigh , \
			MaturityTick , GestationTicks , PregnancyDelayTicks , LatestPregnancyTick, MaxPregnantTick , BirthRate , DeathRate , \
			PhysiologicalNeedsLow , PhysiologicalNeedsHigh , SafetyNeedsLow , SafetyNeedsHigh , AttachmentNeedsLow , AttachmentNeedsHigh , EsteemNeedsLow , EsteemNeedsHigh , \
			ActualizationNeedsLow , ActualizationNeedsHigh , NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh , \
			ConsumptionBeliefsSpec , PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData , PowerBlockData , \
			PrintFlow
#
	if PrintFlow: print "   GenerateAgents"
# Determine StartingPopulationSize.
	GenerateWorldViewCombinations ( )
	ScalePopulation ( )	
# Prepare to generate agents.
	AgentData 										= list( )
	PowerBlockData 									= list( )
	for Index in range ( 0 , len( PowersSpec ) ) :
		PowerBlockData								. append( ( 0 , 0 ) ) # Iniital Beginning and Ending Indices of Power blocks.
# Create empty lists for data that will be used during the simulation.
	ClaimsData 										= list( )
	AllocationsData 								= list( )
#
	AgentID											= 0 # Agents will be uniquely ID'd for sampling during simulation. May convert to list tracking location in AgentData.
	WorldViewIndex 									= 0 # Multiple cycles of WorldViewCombinations will be used to assign WorldViews to new Agents.
#
# Create male Agents with WorldView combinations just generated; cycle through these combinations repeatedly, starting at the beginning.
#
	Gender 											= "Male"
	PregnancyStatus 								= "Never"
	for Age in range ( 0 , MaxTick + 1 ) :
		for Agent in range ( 0 , NumberOfMalesByTick [ Age ] ) :
			AgentID									= AgentID + 1
			PersonalData 							= ( AgentID , Age , Gender, PregnancyStatus )
# Cycle through WorldViewCombinations.
			if WorldViewIndex 						>= len( WorldViewCombinations ) : WorldViewIndex = 0 # Cycle WorldViewCombinations.
			WorldViewData 							= ( WorldViewCombinations [ WorldViewIndex ] [ 1 ] , WorldViewCombinations [ WorldViewIndex ] [ 2 ] )
# Add AffinityData.
			AffinityData 							= list( )
			for Affinity in range ( 0, len ( AffinitiesSpec ) ) :
				if AffinitiesSpec [ Affinity ] [ 1 ] == WorldViewCombinations [ WorldViewIndex ] [ 0 ] : # Compare Affinity to SupplyBelief.
					AffinityData 					. append( Affinity )
# Add randomized BiasesData.
			RiskAcceptanceEffect			 		= round( RiskAcceptanceEffectLow + random.random ( ) 	* ( RiskAcceptanceEffectHigh - RiskAcceptanceEffectLow ) 	, 2 )
			RiskAvoidanceEffect 					= round( RiskAvoidanceEffectLow + random.random ( ) 	* ( RiskAvoidanceEffectHigh - RiskAvoidanceEffectLow  ) 	, 2 )
			BelongingnessEffect 					= round( BelongingnessEffectLow + random.random ( ) 	* ( BelongingnessEffectHigh - BelongingnessEffectLow ) 		, 2 )
			ThoughtLeaderEffect 					= round( HaloEffectLow + random.random ( ) 				* ( HaloEffectHigh - HaloEffectLow ) 						, 2 )
			MemoryEffect 							= round( MemoryEffectLow + random.random ( ) 			* ( MemoryEffectHigh - MemoryEffectLow ) 					, 2 )
			DenialEffect 							= round( DenialEffectLow + random.random ( )			* ( DenialEffectHigh - DenialEffectLow ) 					, 2 )
			BiasesData 								= ( RiskAcceptanceEffect , RiskAvoidanceEffect , BelongingnessEffect , ThoughtLeaderEffect , MemoryEffect , DenialEffect )
# Add randomized NeedsData.
			PhysiologicalNeed 						= round( PhysiologicalNeedsLow  + random.random ( ) 	* ( PhysiologicalNeedsHigh - PhysiologicalNeedsLow ) 		, 2 )
			SafetyNeed 								= round( SafetyNeedsLow + random.random ( ) 			* ( SafetyNeedsLow - SafetyNeedsHigh ) 						, 2 )
			AttachmentNeed 							= round( AttachmentNeedsLow + random.random ( ) 		* ( AttachmentNeedsHigh - AttachmentNeedsLow ) 				, 2 )
			EsteemNeed 								= round( EsteemNeedsLow + random.random ( ) 			* ( EsteemNeedsHigh - EsteemNeedsLow ) 						, 2 )
			ActualizationNeed 						= round( ActualizationNeedsLow + random.random ( ) 		* ( ActualizationNeedsHigh - ActualizationNeedsLow ) 		, 2 )
			NeedsNotMetTolerance 					= random.randint ( NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh )
			NeedsData 								= ( PhysiologicalNeed , SafetyNeed , AttachmentNeed , EsteemNeed , ActualizationNeed , NeedsNotMetTolerance )
# Create new male Agent.
			CreateNewAgent ( )
			WorldViewIndex 							= WorldViewIndex + 1
#
# Create female Agents. Similar to males, with added processing re births and pregnancy.
#
	Gender 											= "Female"
#
# Make some females pregnant to different degrees, and make some others recently-delivered to different degrees.
# Method:
#	Calculate number of females to make pregnant as BirthRate * StartingPopulation with PregnancyStatus between 1 and GestationTicks (all to give birth next Cycle).
#	Calculate number of females that gave birth prior to the simulation as StartingPopulation * (BirthRate - DeathRate) * (PregnancyDelayTicks / GestationTicks), \
#		with PregnancyStatus between -1 and -PregnancyDelayTicks.
#	Evenly spread these over new female Agents aged MaturityTick through LatestPregnancyTick, without overlap.
#
	NumberOfFemalesToMakePregnant 					= BirthRate * StartingPopulationSize
	NumberOfFemalesToAvoidPregnancy 				= ( BirthRate - DeathRate ) * StartingPopulationSize * ( PregnancyDelayTicks / GestationTicks )
	NumberOfPregnancyEligibleFemales 				= 0
	for TickIndex in range ( MaturityTick , MaxPregnantTick + 1 ) :
		NumberOfPregnancyEligibleFemales 			= NumberOfPregnancyEligibleFemales + NumberOfFemalesByTick [ TickIndex ]
	while NumberOfFemalesToMakePregnant + NumberOfFemalesToAvoidPregnancy > NumberOfPregnancyEligibleFemales :
		NumberOfFemalesToMakePregnant 				= NumberOfFemalesToMakePregnant - 1
		NumberOfFemalesToAvoidPregnancy 			= NumberOfFemalesToAvoidPregnancy - 1
	NumberOfFemalesToMakePregnantEachTick 			= int ( NumberOfFemalesToMakePregnant / ( MaxPregnantTick - MaturityTick + 1 ) )
	NumberOfFemalesToAvoidPregnancyEachTick			= int ( NumberOfFemalesToAvoidPregnancy / ( MaxPregnantTick - MaturityTick + 1 ) )
#
	for Age in range ( 0 , MaxTick + 1 ) :		
		NumberOfFemalesPregnancyStatusAlteredThisTick 				= 0
		for Agent in range ( 0 , NumberOfFemalesByTick [ Age ] ) : # Create data for all females at this age.
			PregnancyStatus 										= 0 # Default.
			if MaturityTick <= TickIndex <= MaxPregnantTick : # Set pregnancy status; first block for making pregnant, second block for avoiding pregnancy.
				if NumberOfFemalesPregnancyStatusAlteredThisTick 	< NumberOfFemalesToMakePregnantEachTick :
					PregnancyStatus 								= random.randint ( 1 , GestationTicks )
					NumberOfFemalesPregnancyStatusAlteredThisTick 	= NumberOfFemalesPregnancyStatusAlteredThisTick + 1
				elif NumberOfFemalesPregnancyStatusAlteredThisTick 	< NumberOfFemalesToMakePregnantEachTick + NumberOfFemalesToAvoidPregnancyEachTick :
					PregnancyStatus 								= random.randint ( - PregnancyDelayTicks , - 1 )
					NumberOfFemalesPregnancyStatusAlteredThisTick 	= NumberOfFemalesPregnancyStatusAlteredThisTick + 1
#
			AgentID									= AgentID + 1
			PersonalData 							= ( AgentID , Age , Gender, PregnancyStatus )
# Cycle through WorldViewCombinations.
			if WorldViewIndex 						>= len( WorldViewCombinations ) : WorldViewIndex = 0 # Cycle WorldViewCombinations.
			WorldViewData 							= ( WorldViewCombinations [ WorldViewIndex ] [ 1 ] , WorldViewCombinations [ WorldViewIndex ] [ 2 ] )
# Add AffinityData, i.e. the WorldView that matches that assigned above.
			AffinityData 							= list( )
			for Affinity in range ( 0, len ( AffinitiesSpec ) ) :
				if 	AffinitiesSpec [ Affinity ] [ 1 ] == WorldViewData [ 0 ] : # Compare Affinity to SupplyBelief.
					AffinityData . append( Affinity )
# Add randomized BiasesData.
			RiskAcceptanceEffect 					= round( RiskAcceptanceEffectLow + random.random ( )	* ( RiskAcceptanceEffectHigh - RiskAcceptanceEffectLow ) 	, 2 )
			RiskAvoidanceEffect 					= round( RiskAvoidanceEffectLow + random.random ( )	 	* ( RiskAvoidanceEffectHigh - RiskAvoidanceEffectLow  ) 	, 2 )
			BelongingnessEffect 					= round( BelongingnessEffectLow + random.random ( ) 	* ( BelongingnessEffectHigh - BelongingnessEffectLow ) 		, 2 )
			ThoughtLeaderEffect 					= round( HaloEffectLow + random.random ( ) 				* ( HaloEffectHigh - HaloEffectLow ) 						, 2 )
			MemoryEffect 							= round( MemoryEffectLow + random.random ( ) 			* ( MemoryEffectHigh - MemoryEffectLow ) 					, 2 )
			DenialEffect 							= round( DenialEffectLow + random.random ( ) 			* ( DenialEffectHigh - DenialEffectLow ) 					, 2 )
			BiasesData = ( RiskAcceptanceEffect , RiskAvoidanceEffect , BelongingnessEffect , ThoughtLeaderEffect , MemoryEffect , DenialEffect )
# Add randomized NeedsData.
			PhysiologicalNeed 						= round( PhysiologicalNeedsLow  + random.random ( ) 	* ( PhysiologicalNeedsHigh - PhysiologicalNeedsLow ) 		, 2 )
			SafetyNeed 								= round( SafetyNeedsLow + random.random ( ) 			* ( SafetyNeedsLow - SafetyNeedsHigh ) 						, 2 )
			AttachmentNeed 							= round( AttachmentNeedsLow + random.random ( ) 		* ( AttachmentNeedsHigh - AttachmentNeedsLow ) 				, 2 )
			EsteemNeed 								= round( EsteemNeedsLow + random.random ( ) 			* ( EsteemNeedsHigh - EsteemNeedsLow ) 						, 2 )
			ActualizationNeed 						= round( ActualizationNeedsLow + random.random ( ) 		* ( ActualizationNeedsHigh - ActualizationNeedsLow ) 		, 2 )
			NeedsNotMetTolersance 					= random.randint ( NeedsNotMetToleranceLow , NeedsNotMetToleranceHigh )
			NeedsData 								= ( PhysiologicalNeed , SafetyNeed , AttachmentNeed , EsteemNeed , ActualizationNeed , NeedsNotMetTolerance )
# Create new female Agent.
			CreateNewAgent ( )
			WorldViewIndex			 				= WorldViewIndex + 1

def CreateNewAgent ( ) :
#
# This function avoids sorting AgentData by Power (an N^2 process) by inserting a new Agent record at a randomly-chosen location in the appropriate Power block.
#
	import	random
#
	global	AgentData , PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData , PowerBlockData , \
			PrintFlow
#
	TotalPersonalStorage	=	0
	DataToInsert			= 	[ PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData, TotalPersonalStorage ] # Created in AgentData.
	PowerIndex				= 	WorldViewData [ 1 ] # Obtain PowerSpec Index from WorldViewData.
	BeginningBlockIndex		=	PowerBlockData [ PowerIndex ] [ 0 ] # Obtain current starting location in AgentData of target Power block.
#
	AgentData				.	insert( BeginningBlockIndex , DataToInsert ) # Insert a new Agent into AgentData at the beginnig of the relevant Power block.
# Increment this and 'downstream' blocks' beginning and ending AgentData locations.
	for PowerBlockIndex in range ( PowerIndex , len( PowersSpec ) ) : # Adjust all 'downstream' beginning and ending AgentData locations in PowerData.
		BeginningIncrement	=	0 # Don't change beginning location for the Power block just inserted into.
		if PowerBlockIndex	>	PowerIndex : BeginningIncrement = 1
		PowerDataItem		=	list( ) # Re-used.
		PowerDataItem		=	PowerBlockData . pop( PowerBlockIndex )
		PowerBlockData		.	insert( PowerBlockIndex , ( ( PowerDataItem [ 0 ] + BeginningIncrement ) , ( PowerDataItem [ 1 ] + 1 ) ) )

def GenerateWorldViewCombinations ( ) :
#
# This function constructs a base list of worldviews by generating all possible combinations of SupplyBeliefs, ConsumptionBeliefs and Powers, in their relative frequencies.
#
# Notes:
#	SupplyBeliefsSpec, ConsumptionBeliefsSpec and PowersSpec are lists consisting of tuples of the form (text,frequency,[consumption]); only frequency is used here.
#
	import math
#
	global	SupplyBeliefsSpec , ConsumptionBeliefsSpec , PowersSpec , WorldViewCombinations , \
			PrintFlow
#
	if PrintFlow : print "      WorldViewCombinations"
# Generate minimum list accounting for all WorldView parameter combinations.
	WorldViewCombinations = list( )
#
	EndSupplyBeliefRange = len( SupplyBeliefsSpec ) - 1 # Combinations will generated on a shorter list, since the first record will be removed.
	if SupplyBeliefsSpec [ 0 ] [ 1 ] : # Ignore rest of SupplyBelefsSpec.
		EndSupplyBeliefRange = 1
	SupplyBeliefsSpec . pop ( 0 )
#
	EndConsumptionBeliefRange = len( ConsumptionBeliefsSpec ) - 1
	if ConsumptionBeliefsSpec [ 0 ] [ 1 ] : # Ignore rest of ConsumptionBelefsSpec.
		EndConsumptionBeliefRange = 1
	ConsumptionBeliefsSpec . pop ( 0 )
#
	EndPowerRange = len( PowersSpec ) - 1
	if PowersSpec [ 0 ] [ 1 ] : # Ignore rest of PowersSpec.
		EndPowerRange = 1
	PowersSpec . pop ( 0 )
#
	for SupplyBeliefIndex in range ( 0 , EndSupplyBeliefRange ) :	
		for SupplyBeliefFrequency in range ( 0 , SupplyBeliefsSpec [ SupplyBeliefIndex ] [ 1 ] ) :
			for ConsumptionBeliefIndex in range ( 0 , EndConsumptionBeliefRange ) :
				for ConsumptionBeliefFrequency in range ( 0 , ConsumptionBeliefsSpec [ ConsumptionBeliefIndex ] [ 1 ] ) :
					for PowerIndex in range ( 0 , EndPowerRange ) :
						for PowerFrequency in range ( 0 , PowersSpec [ PowerIndex ] [ 1 ] ) :
							WorldViewCombinations . append ( ( SupplyBeliefIndex , ConsumptionBeliefIndex , PowerIndex ) )

def ScalePopulation ( ) :
#
# This function determines a StartingPopulationSize that maintain the relative numbers of WorldView combinations at that just determined, as well as the relative numbers
# of age and gender combinations provided. This is done by finding the Lowest Common Multiple (LCM) of len(WorldViewCombinations) and len(NominalPopulation), then applying
# the smallest multiple that exceeds ApproximateStartingPopulation.
#
# Male/Female splits are averaged from this source: http://www.statcan.gc.ca/pub/89-503-x/2010001/article/11475/tbl/tbl001-eng.htm
#
	global	ApproximateStartingPopulationSize , AbsoluteMaximumPopulationSize , \
			StartingPopulationSize , NominalPopulationSpec , MalePopulationFraction , PopulationCountBasis , NumberOfMalesByTick , NumberOfFemalesByTick , \
			WorldViewCombinations , TotalNominalConsumption , TotalNominalPopulation , \
			PrintFlow
#
	import math
	import random
	if PrintFlow: print "      ScalePopulation"
#
# Calculate unit size of a population featuring one full set of WorldView combintations for one full set of AgeGender combinations.
# This value is equal to the Least Common Multiple of the number of the numbers of each of these.
#
	AgeGenderCombinations 			= int( 2 * len( NominalPopulationSpec ) )
	UnitPopulationSize 				= ( len( WorldViewCombinations ) * AgeGenderCombinations ) / GreatestCommonDivisor ( len( WorldViewCombinations ) , AgeGenderCombinations )
	print "         TicksThisSimulation" , NumTicksEachSimulation
	print "         AgeGenderCombinations" , AgeGenderCombinations
	print "         WorldViewCombinations" , len( WorldViewCombinations )
	print "         UnitPopulationSize" , UnitPopulationSize
#
# Calculate the number of these units required genrate a population that is not smaller than the ApproximateStartingPopulationSize.
#
	NumberOfPopulationUnits 		= int( math.ceil( float( ApproximateStartingPopulationSize ) / float( UnitPopulationSize ) ) )
	ProvisionalPopulationSize		= UnitPopulationSize * NumberOfPopulationUnits
	print "         ApproximatePopulationSize" , ApproximateStartingPopulationSize
	print "         NumberOfUnits" , NumberOfPopulationUnits
	print "         ProvisionalPopulationSize" , ProvisionalPopulationSize
#
# Since further scaling will be done using NominalPopulation values, ensure that the smallest of these results in a final population of at least 1 while preserving full sets
# of WorldView and AgeGender combinationts, by findig the smallest multiple of StartingPopulation that ensures at least 1 in every AgeGender combination.
#
	SmallestNominalPopulationValue = 501.0 # All are 5 * % values, ie less than 501.
	for TickIndex in range ( 0 , len( NominalPopulationSpec ) ) :
		if NominalPopulationSpec [ TickIndex ] [ 1 ] < SmallestNominalPopulationValue : SmallestNominalPopulationValue = NominalPopulationSpec [ TickIndex ] [ 1 ]
		if NominalPopulationSpec [ TickIndex ] [ 2 ] < SmallestNominalPopulationValue : SmallestNominalPopulationValue = NominalPopulationSpec [ TickIndex ] [ 2 ]
	TheoreticalStartingPopulationSize 		= int( 2.0 * float( ProvisionalPopulationSize ) / float( SmallestNominalPopulationValue ) )
	print "         SmallesNomPopSpec" , SmallestNominalPopulationValue
	print "         TheoreticalStartingPopulationSize" , TheoreticalStartingPopulationSize 
	NumberOfMalesByTick 					= list ( )
	NumberOfFemalesByTick 					= list ( )
	RunningTotalOfMales						= 0
	RunningTotalOfFemales					= 0
	MaxTotalOfMales							= int( round( MalePopulationFraction * float( TheoreticalStartingPopulationSize ) , 0 ) )
	MaxTotalOfFemales						= int( round( ( 1.0 - float( MalePopulationFraction ) ) * float( TheoreticalStartingPopulationSize ) , 0 ) )
	for TickIndex in range ( 0 , len( NominalPopulationSpec ) ) : # Adjust for %, replication of 5-year StatsCan data, and unequal gender split.
		ProposedNumberOfMalesToAdd			= int( math.ceil(	float( TheoreticalStartingPopulationSize ) * \
																float( NominalPopulationSpec [ TickIndex ] [ 1 ] ) * PopulationCountBasis * MalePopulationFraction ) )
		NumberOfMalesThisTick				= min( ProposedNumberOfMalesToAdd , MaxTotalOfMales - RunningTotalOfMales )
		NumberOfMalesByTick					. append ( NumberOfMalesThisTick )
		RunningTotalOfMales					= RunningTotalOfMales + NumberOfMalesThisTick
		ProposedNumberOfFemalesToAdd		= int( math.ceil(	float( TheoreticalStartingPopulationSize ) * float( NominalPopulationSpec [ TickIndex ] [ 1 ] ) * \
																PopulationCountBasis * ( 1.0 - float( MalePopulationFraction ) ) ) )
		NumberOfFemalesThisTick				= min( ProposedNumberOfFemalesToAdd , MaxTotalOfFemales - RunningTotalOfFemales )
		NumberOfFemalesByTick  				. append ( NumberOfFemalesThisTick )
		RunningTotalOfFemales				= RunningTotalOfFemales + NumberOfFemalesThisTick
	BottomUpStartingPopulationSize			= RunningTotalOfMales + RunningTotalOfFemales
	print "         BottomUpStartingPopulationSize" , BottomUpStartingPopulationSize
#
	AddToMales								= int( round( float( MalePopulationFraction ) * float( TheoreticalStartingPopulationSize - BottomUpStartingPopulationSize ) ) )
	AddToFemales							= int( round( float( 1.0 - MalePopulationFraction ) * float( TheoreticalStartingPopulationSize - BottomUpStartingPopulationSize ) ) )
	for TickIndex in range ( 0 , AddToMales ) :
		PopInsertIndex						= random.randint( 0 , MaxTick )
		NewNumber							= NumberOfMalesByTick [ PopInsertIndex ] + 1
		NumberOfMalesByTick					. pop( PopInsertIndex )
		NumberOfMalesByTick					. insert( PopInsertIndex , NewNumber )
		RunningTotalOfMales					= RunningTotalOfMales + 1
	for TickIndex in range ( 0 , AddToFemales ) :
		PopInsertIndex						= random.randint( 0 , MaxTick )
		NewNumber							= NumberOfFemalesByTick [ PopInsertIndex ] + 1
		NumberOfFemalesByTick 				. pop( PopInsertIndex )
		NumberOfFemalesByTick 				. insert( PopInsertIndex , NewNumber )
		RunningTotalOfFemales				= RunningTotalOfFemales + 1
	StartingPopulationSize					= RunningTotalOfMales + RunningTotalOfFemales
#
	StartingPopulationSize					= int( min( StartingPopulationSize , AbsoluteMaximumPopulationSize ) )
	print "         FinalStartingPopulationSize" , StartingPopulationSize

def GreatestCommonDivisor ( A , B ) : # In conjunction with ScalePopulation, finds the Lowest Common Multiple of two numbers using recursion.
	if B == 0 : return ( A )
	return ( GreatestCommonDivisor ( B , A % B ) )

def RandomizeClaimsAndAllocationsOrder ( ) :
#
# This function sorts AgentData into Power blocks (highest power, lowest index first), then randomizes Agent order within each block.
# Claims will be made and allocated in this order, so Agents with higher Power will be more likely to have their Claims satisfied, though shuffled each Tick
#
	import random
#
	global	AgentData , \
			PrintFlow
#
	if PrintFlow : print "   RandomizeClaimsAllocationsOrder"
# Determine start and end of the each Power block.
	EndAgentDataIndex 						=	len( AgentData ) - 1
	StartAgentIndex 						=	0
	AgentIndex 								=	0
	while AgentIndex <= EndAgentDataIndex :
		Power 								=	AgentData [ StartAgentIndex ] [ 1 ] [ 1 ]
		if AgentIndex == EndAgentDataIndex or AgentData [ AgentIndex + 1 ] [ 1 ] [ 1 ] != Power : # New Power block or end of AgentData; logic order important.
			EndAgentIndex 					=	AgentIndex
#
# Shuffle each Power block using the Fisher-Yates Algorithm (see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle):
#	To shuffle an array a of n elements (indices 0 to n-1)
#	do for i from n-1 to 1
#		j = random integer with 0 <= j <= i
#		exchange a[j] and a[i]
#
			for ShuffleIndex in range ( StartAgentIndex , EndAgentIndex ) :
				InverseShuffleIndex 		=	EndAgentIndex - ShuffleIndex - 1
				RandomShuffleIndex 			=	StartAgentIndex + random.randint ( 0 , InverseShuffleIndex )	
				FirstAgentToMove 			=	AgentData . pop( ShuffleIndex )
				if RandomShuffleIndex > ShuffleIndex : RandomShuffleIndex = RandomShuffleIndex - 1 # Upper part of list is one shorter than prior to above pop.
				SecondAgentToMove 			=	AgentData . pop( RandomShuffleIndex )
				AgentData 					.	insert( RandomShuffleIndex , FirstAgentToMove )
				AgentData 					.	insert( ShuffleIndex , SecondAgentToMove )
# Prepare for next Power block.
			StartAgentIndex 				=	EndAgentIndex + 1
		AgentIndex 							=	AgentIndex + 1

def CalculateAgentsClaims ( ) :
#
# This function calculates current-Tick Agents' Claims independently, in the order determined by RandomizeClaimsAndAllocationsOrder (can change each SimTick).
#
	import random
	import copy
#
	global	SimTick , AgentData , MemoryTicks , RetirementTick , ConsumptionBeliefsSpec , TotalNominalPopulation , TotalNominalConsumption , EnergySupplyFactors , \
			FullClaimFactors , RetirementClaimFactors , FirstTickTotalEnergy , CommunityStorage , InitialCommunityStorageMultiple, CommunityStorageDiversionFactor , \
			PrintFlow
#
	if PrintFlow :
		print " "
		print "   AgentsMakeClaims"
	TotalEnergySupplyThisTick						=	0
	TotalClaimsThisTick								= 	0
#
	for Agent in range ( 0 , len( AgentData ) ) :
		AgentTick 									= 	AgentData [ Agent ] [ 0 ] [ 1 ]
		ConsumptionBeliefIndexThisAgent				= 	AgentData [ Agent ] [ 1 ] [ 0 ]
		PhysiologicalNeedsThisAgent					= 	AgentData [ Agent ] [ 4 ] [ 0 ]
		SafetyNeedsThisAgent						= 	AgentData [ Agent ] [ 4 ] [ 1 ]
		AttachmentNeedsThisAgent					= 	AgentData [ Agent ] [ 4 ] [ 2 ]
		EsteemNeedsThisAgent						= 	AgentData [ Agent ] [ 4 ] [ 3 ]
		ActualizationNeedsThisAgent					= 	AgentData [ Agent ] [ 4 ] [ 4 ]		
		AllNeedsThisAgent							= 	PhysiologicalNeedsThisAgent + SafetyNeedsThisAgent + AttachmentNeedsThisAgent + \
														EsteemNeedsThisAgent + ActualizationNeedsThisAgent
#
# First MemoryTicks EnergySupplyThisAgent based on ConsumptionBeliefsSpec.
# After first MemoryTicks, EnergySupplyThisAgent is calculated as first Tick Allocation (= first Tick Claim) * EnergySupplyFactors [ SimTick ].
#
		if SimTick < MemoryTicks :
			EnergySupplyThisAgent					=	float( EnergySupplyFactors [ SimTick ] ) * float( StartingPopulationSize ) / float( TotalNominalPopulation ) * \
														float( ConsumptionBeliefsSpec [ ConsumptionBeliefIndexThisAgent ] [ 2 ] )
			CommunityStorage						=	float( EnergySupplyThisAgent ) 					* float( InitialCommunityStorageMultiple )
		else :
			TotalEnergyFirstClaimAllocation			=	float( AgentData [ Agent ] [ 6 ] [ 0 ] [ 2 ] )
			EnergySupplyThisAgent					=	float( EnergySupplyFactors [ SimTick ] ) 		* TotalEnergyFirstClaimAllocation
			CommunityStorageDiversionThisAgent		=	float( EnergySupplyThisAgent ) 					* float( CommunityStorageDiverstionFactor )
			EnergySupplyThisAgent					=	float( EnergySupplyThisAgent ) 					- float( CommunityStorageDiversionThisAgent )
			CommunityStorage						=	float( CommunityStorage )						+ float( CommunityStorageDiversionThisAgent )
#
#	History Creation, non-retirees.
#
		if SimTick < MemoryTicks and AgentTick < RetirementTick : # In History Creation Phase for non-retirees.
#
			if ConsumptionBeliefIndexThisAgent == 0 :
				PersonalUsageClaimThisAgent 		=	float( EnergySupplyThisAgent ) / ( 1 + float( FullClaimFactors [ 1 ] [ 0 ] ) + float( FullClaimFactors [ 2 ] [ 0 ] ) )
				PersonalStorageClaimThisAgent		= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 			= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent == 1 :
				PersonalUsageClaimThisAgent 		=	float( EnergySupplyThisAgent ) / ( 1 + float( FullClaimFactors [ 1 ] [ 1 ] ) + float( FullClaimFactors [ 2 ] [ 1 ] ) )
				PersonalStorageClaimThisAgent		= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 			= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent == 2 :
				PersonalUsageClaimThisAgent 		=	float( EnergySupplyThisAgent ) / ( 1 + float( FullClaimFactors [ 1 ] [ 2 ] ) + float( FullClaimFactors [ 2 ] [ 2 ] ) )
				PersonalStorageClaimThisAgent		= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 			= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent == 3 :
				PersonalUsageClaimThisAgent 		=	float( EnergySupplyThisAgent ) / ( 1 + float( FullClaimFactors [ 1 ] [ 3 ] ) + float( FullClaimFactors [ 2 ] [ 3 ] ) )
				PersonalStorageClaimThisAgent		= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 			= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent == 4 :
				PersonalUsageClaimThisAgent 		=	float( EnergySupplyThisAgent ) / ( 1 + float( FullClaimFactors [ 1 ] [ 4 ] ) + float( FullClaimFactors [ 2 ] [ 4 ] ) )
				PersonalStorageClaimThisAgent		= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 			= 	float( PersonalUsageClaimThisAgent ) * float( FullClaimFactors [ 2 ] [ 4 ] )
#
# Normal Operation, before Retirement.
#
		if SimTick >= MemoryTicks and AgentTick < RetirementTick :
#
			if ConsumptionBeliefIndexThisAgent 	== 0 :
				MaxTotalClaimThisAgent				 		=	float( 0 )
				for MemoryIndex in range ( 0 , MemoryTicks ) :
					if float( AgentData [ Agent ] [ 5 ] [ MemoryIndex ] [ 0 ] ) > MaxTotalClaimThisAgent :
						MaxTotalClaimThisAgent			 	=	float( AgentData [ Agent ] [ 5 ] [ MemoryIndex ] [ 0 ] )
				PersonalUsageClaimThisAgent					= 	float( MaxTotalClaimThisAgent )
				PersonalStorageClaimThisAgent				=	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 					= 	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 1 :
				TotalClaimsThisAgent				 		= 	float( 0 )
				for MemoryIndex in range ( 0 , MemoryTicks ) :
					TotalClaimsThisAgent				 	=	float( TotalClaimsThisAgent ) 						+ float( AgentData [ Agent ] [ 5 ] [ MemoryIndex ] [ 0 ] )
				AverageTotalClaimThisAgent			 		=	float( TotalClaimsThisAgent ) 						/ float( MemoryTicks )
				PersonalUsageClaimThisAgent 				=	float( AverageTotalClaimThisAgent )
				PersonalStorageClaimThisAgent				=	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 					= 	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 2 :
				PersonalUsageClaimThisAgent 				=	max( float( AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 0 ] ) , float( AllNeedsThisAgent ) )
				PersonalStorageClaimThisAgent				=	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 					= 	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 3 :
				PersonalUsageClaimThisAgent 				=	float( AllNeedsThisAgent ) * float( FullClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent				=	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 					= 	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent 	== 4 :
				PersonalUsageClaimThisAgent 				=	float( PhysiologicalNeedsThisAgent ) 				* float( FullClaimFactors [ 0 ] [ 4 ] )
				PersonalStorageClaimThisAgent				=	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 					= 	float( PersonalUsageClaimThisAgent ) 				* float( FullClaimFactors [ 2 ] [ 4 ] )
#
# History Creation Phsae, retireees.
#
		if SimTick <= MemoryTicks and AgentTick >= RetirementTick :
#
			if ConsumptionBeliefIndexThisAgent	== 0 :
				PersonalUsageClaimThisAgent 				=	float( EnergySupplyThisAgent ) 				/ \
																( 1 + float( RetirementClaimFactors [ 1 ] [ 0 ] ) 	+ float( RetirementClaimFactors [ 2 ] [ 0 ] ) )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 1 :
				PersonalUsageClaimThisAgent 				=	float( EnergySupplyThisAgent ) 				/ \
																( 1 + float( RetirementClaimFactors [ 1 ] [ 1 ] ) 	+ float( RetirementClaimFactors [ 2 ] [ 1 ] ) )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 2 :
				PersonalUsageClaimThisAgent 				=	float( EnergySupplyThisAgent ) 				/ \
																( 1 + float( RetirementClaimFactors [ 1 ] [ 2 ] ) 	+ float( RetirementClaimFactors [ 2 ] [ 2 ] ) )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 3 :
				PersonalUsageClaimThisAgent 				=	float( AllNeedsThisAgent ) 							* 	float( RetirementClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 3 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 4 :
				PersonalUsageClaimThisAgent 				=	float( PhysiologicalNeedsThisAgent ) 				* 	float( RetirementClaimFactors [ 0 ] [ 4 ] )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 4 ] )
#
# Normal operation, retirees.
#
		if SimTick > MemoryTicks and AgentTick >= RetirementTick :
#
			MaxTotalClaimThisAgentOverMemoryTicks			=	0
			for MemoryIndex in range ( 0 , MemoryTicks ) :
				if float( AgentData [ Agent ] [ 5 ] [ MemoryIndex ] [ 0 ] ) > MaxTotalClaimThisAgentOverMemoryTicks :
					MaxTotalClaimThisAgentOverMemoryTicks 	=	float( AgentData [ Agent ] [ 5 ] [ MemoryIndex ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 0 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 0 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 0 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 1 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 1 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 1 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 2 :
				PersonalUsageClaimThisAgent 				=	float( MaxTotalClaimThisAgentOverMemoryTicks )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 2 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 2 ] )
#
			if ConsumptionBeliefIndexThisAgent	== 3 :
				PersonalUsageClaimThisAgent 				=	float( AllNeedsThisAgent ) 							* 	float( RetirementClaimFactors [ 0 ] [ 3 ] )
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 3 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 3 ] )			
#
			if ConsumptionBeliefIndexThisAgent	== 4 :
				PersonalUsageClaimThisAgent 				=	float( PhysiologicalNeedsThisAgent ) 				* 	float( RetirementClaimFactors [ 0 ] [ 4 ] )			
				PersonalStorageClaimThisAgent 				=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 1 ] [ 4 ] )
				ContributionClaimThisAgent 					=	float( PersonalUsageClaimThisAgent ) 				* 	float( RetirementClaimFactors [ 2 ] [ 4 ] )
#
# Apply RiskAcceptance (usage) and RiskAvoidance (storage) Cognitive Biases.
#
#		RiskAcceptanceEffect 				= 	float( AgentData [ Agent ] [ 3 ] [ 0 ] )
#		RiskAvoidanceEffect 				= 	float( AgentData [ Agent ] [ 3 ] [ 1 ] )
#		PersonalUsageClaimThisAgent 		= 	float( PersonalUsageClaimThisAgent ) 	* 	( 	float( 1 )	+ 	RiskAcceptanceEffect 	)
#		PersonalStorageClaimThisAgent 		= 	float( PersonalStorageClaimThisAgent ) 	*	(	float( 1 ) 	- 	RiskAvoidanceEffect 	)
#		ContributionClaimThisAgent 			= 	float( ContributionClaimThisAgent ) 	* 	( 	float( 1 )	- 	RiskAvoidanceEffect 	)
#
		TotalClaimsThisAgent				= 	int( PersonalUsageClaimThisAgent ) + int( PersonalStorageClaimThisAgent ) + int( ContributionClaimThisAgent )
		TotalClaimsThisTick					=	TotalClaimsThisTick + TotalClaimsThisAgent
#
		PersonalData 						= 	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		WorldViewData 						= 	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		AffinityData 						= 	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		BiasesData 							= 	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		NeedsData 							= 	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		ClaimsData 							= 	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		AllocationsData 					= 	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		TotalPersonalStorage				=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
#
		if len( ClaimsData ) ==	MemoryTicks : # Remove first element in the list and append the (modified) element; result is a max-length history.
			ClaimsData						.	pop( )
		ClaimsData 							. 	append( ( 	int( PersonalUsageClaimThisAgent ) , int( PersonalStorageClaimThisAgent ) , \
															int( ContributionClaimThisAgent ) , int( TotalClaimsThisAgent ) ) )
#
		AgentData 							. 	insert( Agent , [ PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData , 
			 									TotalPersonalStorage ] ) # New data.
		AgentData							.	pop( Agent + 1 ) # Old data.
#
	print "      TotalClaimsThisTick" , TotalClaimsThisTick
	if SimTick == 0:
		FirstTickTotalEnergy				=	int( TotalClaimsThisTick )

def AllocateEnergyToAgents ( ) :
#
# This function allocates the available energy to Agents.
# Initially this is done in the order they are listed (by Power block, randomized within Power block every SimTick).
# If there are any deficient Allocztions, CommunityStorage will be used to topup to Agents' Physiological Needs in the reverse order in which they were recorded.
# Exception: All Agents' Claims in the History Creation period (MemoryTicks in length) will automatically have their Claims met, ie Allocations will be made = Claims.
#
	import copy
#
	global	SimTick , AgentData , MemoryTicks , FirstTickTotalEnergy , CommunityStorage , FirstMessageThisTick , \
			PrintFlow 
#
	if PrintFlow : print "   AllocateEnergyToAgents"
#
	EnergyAvailableToBeAllocatedThisTick				=	FirstTickTotalEnergy * EnergySupplyFactors [ SimTick ]
	TotalAllocationsThisTick							=	0
	DeficientAllocationList								=	list( )
	for Agent in range ( 0 , len( AgentData ) ) :
		TotalAllocationsThisAgent						=	0
		PersonalData									=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
		WorldViewData									=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
		AffinityData									=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
		BiasesData										=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
		NeedsData										=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
		ClaimsData										=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
		AllocationsData									=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
		TotalPersonalStorage							=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
#
		if SimTick < MemoryTicks : # Make TotalAllocations equal to TotalClaims during History Creation period, ie cannot result in unmet Claims.
			PersonalUsageAllocationThisAgent			=	float( AgentData [ Agent ] [ 5 ] [ SimTick ] [ 0 ] )
			PersonalStorageAllocationThisAgent			=	float( AgentData [ Agent ] [ 5 ] [ SimTick ] [ 1 ] )
			ContributionAllocationThisAgent				=	float( AgentData [ Agent ] [ 5 ] [ SimTick ] [ 2 ] )
		else : # Otherwise, total available to allocated is based on the first SimTick's total Claim/Allocation.
#
			if AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 0 ] 	<=	EnergyAvailableToBeAllocatedThisTick : # Fulfill full PersonalUsage Claim for this Agent.
				PersonalUsageClaimThisAgent				=	float( AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 0 ] )
				PersonalUsageAllocationThisAgent		=	float( PersonalUsageClaimThisAgent )
				EnergyAvailableToBeAllocatedThisTick 	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( PersonalUsageAllocationThisAgent )
			else : # EnergyAvailable will be exhausted with this Allocation.
				PersonalUsageAllocationThisAgent 		=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
# Draw from TotalPersonalStorage.
				Deficiency								=	float( PersonalUsageClaimThisAgent ) - float( PersonalUsageAllocationThisAgent )
				if Deficiency <= TotalPersonalStorage :
					PersonalUsageAllocationThisAgent	=	float( PersonalUsageAllocationThisAgent ) + float( Deficiency )
					TotalPersonalStorage				=	float( TotalPersonalStorage ) - float( Deficiency )
				else :
					PersonalUsageAllocationThisAgent	=	float( PersonalUsageAllocationThisAgent ) + float( TotalPersonalStorage )
					TotalPersonalStorage				=	float( 0 )
					DeficientAllocationList				.	append( Agent ) # Look to CommunityStorage for futher top-up; see below.
#
			if AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 1 ] 	<=	EnergyAvailableToBeAllocatedThisTick : # Fulfill full PersonalStorage Claim for this Agent.
				PersonalStorageAllocationThisAgent 		=	float( AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 1 ] )
				EnergyAvailableToBeAllocatedThisTick	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( PersonalStorageAllocationThisAgent )
			else: # EnergyAvailble will be exhaused with this Allocation.
				PersonalStorageAllocationThisAgent		=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
#
			if AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [  2 ] <=	EnergyAvailableToBeAllocatedThisTick : # FulFill full CommunityStorage Claim for this Agent.
				ContributionAllocationThisAgent		 	=	float( AgentData [ Agent ] [ 5 ] [ MemoryTicks - 1 ] [ 2 ] )
				EnergyAvailableToBeAllocatedThisTick	=	float( EnergyAvailableToBeAllocatedThisTick ) - float( ContributionAllocationThisAgent )
			else : # EnergyAvailable will be exhausted with this Allocation.
				ContributionAllocationThisAgent		 	=	float( EnergyAvailableToBeAllocatedThisTick )
				EnergyAvailableToBeAllocatedThisTick	=	float( 0 )
#
		CommunityStorage								=	float( CommunityStorage ) + float( ContributionAllocationThisAgent )
#
		TotalAllocationsThisAgent						=	TotalAllocationsThisAgent + \
															PersonalUsageAllocationThisAgent + PersonalStorageAllocationThisAgent + ContributionAllocationThisAgent
		TotalAllocationsThisTick						=	TotalAllocationsThisTick + TotalAllocationsThisAgent
#
		if SimTick >= MemoryTicks :
			AllocationsData 							.	pop( ) # Keep list at length MemoryTicks.
		AllocationsData		 							.	append( ( PersonalUsageAllocationThisAgent , PersonalStorageAllocationThisAgent , ContributionAllocationThisAgent , \
				 											TotalAllocationsThisAgent ) )
#
		AgentData 										. 	insert( Agent , [ PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData , \
			 												TotalPersonalStorage ] )
		AgentData										.	pop( Agent + 1 )
#
# Draw from CommunityStorage in reverse order of DeficientAllocationList to ensure Physiological Needs are met as much as possible
#
	if SimTick >= MemoryTicks :
		for Index in range ( 0 , len( DeficientAllocationList ) ) : # Top up PersonalUsge amounts from CommunityStorage in reverse Power order.
			ReverseIndex								=	len( DeficientAllocationList ) - Index - 1
			Agent										=	DeficientAllocationList [ Index ]
			PersonalData								=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
			WorldViewData								=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
			AffinityData								=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
			BiasesData									=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
			NeedsData									=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
			ClaimsData									=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
			AllocationsData								=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
			TotalPersonalStorage						=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
			PersonalUsageAlllocationThisAgent			=	AllocationsData [ MemoryTicks - 1 ] [ 0 ]
			PersonalUsageClaimThisAgent					=	ClaimsData [ MemoryTicks - 1 ] [ 0 ]
			if PersonalUsageAllocationThisAgent < PersonalUsageClaimThisAgent :
				Deficiency								=	float( PersonalUsageClaimThisAgent ) - float( PersonalUsageAllocationThisAgent )
				if Deficiency <= CommunityStorage :
					PersonalUsageAllocationThisAgent	=	float( PersonalUsageAllocationThisAgent ) 	+ float( Deficiency )
					CommunityStorage					=	float( CommunityStorage ) 					- float( Deficiency )
				else :
					PersonalUsageAllocationThisAgent	=	float( PersonalUsageAllocationThisAgent ) 	+ float( CommunityStorage )
					CommunityStorage					=	float( 0 )
#
			if len( AllocationsData ) == MemoryTicks :
				AllocationsData 						.	pop( ) # Keep list at length MemoryTicks.
			AllocationsData 							.	append( ( PersonalUsageAllocationThisAgent , PersonalStorageAllocationThisAgent , \
				 											ContributionAllocationThisAgent , TotalAllocationsThisAgent ) )
#
			AgentData									. 	insert( Agent , [ PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , ClaimsData , AllocationsData , \
				 											TotalPersonalStorage ] )
			AgentData									.	pop( Agent + 1 )
#
	print "      TotalAllocationsThisTick" , int( TotalAllocationsThisTick )
#
	FirstMessageThisTick = list( ) # Prep for Agents' Discussions by forcing all Agents to express level of satisfaction with allocations vis-a-vis claims prior to consulting affines.
	for Agent in range ( 0 , len ( AgentData ) ) :
		FirstMessageThisTick							.	append( "True" )

#def InterAgentDiscussions ( ) :
#
# This function produces Affines-affected values for Agents' satisfaction with Allocations given Claims in this SimTick.
#
#	import random
#
#	global	AgentData , SimTick , FirstMessageThisTick , TolerableVariationLow , TolerableVariationHigh , MaxMessagesPerTick , BatchAssessment
#
#	NumMessagesThisTick 										=	0
#	VariationToleranceThisTick 									=	random.random ( TolerableVariationLow , TolerableVariationHigh )
#	Inbox														=	list( )
#	while NumMessagesThisTick <	MaxMessagesPerTick :
#		for Agent in range ( 0 , len ( AgentData ) ) :
#			if FirstMessageThisTick [ Agent ] :
#				FirstMessageThisTick							.	insert( Agent , False )
#				FirstMessageThisTick							.	pop( Agent + 1 )
#				SatisfactionValue			 					.	float( AgentData [ Agent ] [ SimTick ] [ 6 ] [ 3 ] ) - float( AgentData [ Agent ] [ SimTick ] [ 5 ] [ 3 ] ) ) / \
#	 																VariationToleranceThisTick
# Apply BelongingnessEffect.
#			else :
#				EvaluateNextBatchOfAffineMessages ( ) Sets BatchAssessment value, a weighted sum of all Affines' SatisfactionValues.
#				SatisfactionValue			 					=	( 	AgentData [ Agent ] [ 8 ] + \
#																		BatchAssessment * random.random ( BelongingnessLow , BelongingnessHigh ) ) / 2
# Record (updated) SatisfactionValue
#			PersonalData										=	copy.deepcopy( AgentData [ Agent ] [ 0 ] )
#			WorldViewData										=	copy.deepcopy( AgentData [ Agent ] [ 1 ] )
#			AffinityData										=	copy.deepcopy( AgentData [ Agent ] [ 2 ] )
#			BiasesData											=	copy.deepcopy( AgentData [ Agent ] [ 3 ] )
#			NeedsData											=	copy.deepcopy( AgentData [ Agent ] [ 4 ] )
#			ClaimsData											=	copy.deepcopy( AgentData [ Agent ] [ 5 ] )
#			AllocationsData										=	copy.deepcopy( AgentData [ Agent ] [ 6 ] )
#			TotalPersonalStorage								=	copy.deepcopy( AgentData [ Agent ] [ 7 ] )
#			AgentData											.	insert( Agent , [ PersonalData , WorldViewData , AffinityData , BiasesData , NeedsData , \
#																	ClaimsData , AllocationsData , TotalPersonalStorage , SatisfactionValue ] )
#			AgentData											.	pop( Agent + 1 )
# Send messages to Affines.
#			if NumMessagesThisTick < MaxMessagesPerTick :
#				if len ( AgentData [ Agent ] [ 3 ] > 0 : # Do not process if this Agent has no affines.
#					for AffinityThisAgent in range ( 0 , len ( AgentData [ Agent ] [ 3 ] ) ) :
#						AffinityIndex 							=	AgentData [ Agent] [ 3 ] [ AffinityThisAgent ]
#							for AgentIndex in range ( 0 , len ( AffinityGroup [ AffinityIndex ] ) ) :
#								RecipientAgent 					=	AffinityGroup [ AffinityIndex ] [ AgentIndex ]
#								if RecipientAgent 	<>	Agent : # Send only to others, not oneself.
#									InBox					 	.	append ( ( RecipientAgent , Agent , SatisfactionValue ) ) # May result in duplicates. OK?
#									NumMessagesThisTick 		=	NumMessagesThisTick + 1 # Global count across all Agents this Tick.
#
#def EvaluateNextBatchOfMessages ( ) :
# Process messages from other Agents within 'time' limits. Messages are in ( Sender, SatisfactionValue ) format.
#	BatchAssessment = 0
#	NumMessagesProcessedThisBatch = 0
#	while 1 == 1 :
#		if len ( InBox [ Agent ] ) > 0 :
#			NumMessagesProcessedThisBatch = NumMessagesProcessedThisBatch + 1
#			if NumMessageProcessedThisBatch < MaxMessagePerBatch : # No more than MaxMessagePerBatch processed this time.
#				MessageToSelect = random.randint ( 1 , len ( InBox [ Agent ] ) )
#				MessageSender = InBox [ Agent ] [ 0 ]
#				SenderSatisfactionValue = InBox [ Agent ] [ 1 ]
#				del InBox [ Agent ]
#				MessageWeight = 1 # Default message weight.
#				if MessageSender in ThoughtLeader [ ] :
#					MessageWeight = random.random ( HaloEffectLow , HaloEffectHigh ) # Apply Halo Effect.
#					BatchAssessment = BatchAssessment + SenderSatisfactionValue * MessageWeight # Will be averaged before returning.
#				BatchAssessment = BatchAssessment ) / ( NumMessagesProcessedThisBatch + 1 ) # Weighted average of affines' and own satisfaction values.
#def AssessWorldView ( ) :
# Determine if SatisfactionValue history mandates a change in WorldView.
#     WindowStartTick = max ( 1 , LongTick - MemoryTicks + 1 ) # Keep at 1 until sufficient Ticks have occurred.
#    WindowEndTick = LongTick
#     if MemoryTicks > 0 :
#          for Agent in range ( 0 , len ( AgentData ) )
# Apply MemoryEffect.
#               for WindowTick in range ( WindowEndTick + 1 , WindowStartTick ,  - 1 ) # Examine historic SatisfactionValues from most recent to least recent.
#                    WeightedAllocationMinusClaim =  Weighted AllocationMinusClaim + \
#                         WindowTick * ( AgentData [ Agent ] [ WindowTick ] [ 6 ] [ 3 ] - AgentData [ Agent ] [ WindowTick ] [ 5 ] [ 3 ] )
#               WeightedAllocationMinusClaim = WeightedAllocationMinusClaim / ( WindowEndTick - WindowStartTick ) * ( WindowEndTick - WindowStartTick + 1 ) * 2 
# Apply DenialEffect.
#               WeightedAllocationMinusClaim = WeightedAllocationMinusClaim * (1 - DenialEffect [ Agent ] )
#               WorldViewChangeIndicator [ Agent ] =   No change.  
#               If WeightedAllocationMinusClaim > VariationToleranceThisTick : WorldViewChangeIndicator [ Agent ] =   Downscale  
#               if WeightedAllocationMinusClaim > VariationToleranceThisTick : WorldViewChangeIndicator [ Agent ] =  Upscale 
#def AdjustWorldView ( ) :
#     for Agent in range ( 0, len ( AgentData ) :
#          If WorldViewChangeIndicator [ Agent ] =   Downscale  :
#               if AgentData [ Agent ] [ 1 ] [ 1 ] = ConsumptionBelief [ 4 ] : # No room to downscale.
#                    NeedsNotMetIndicator [ Agent ] = True # Kill off Agent in AdjustPopulation.
#               else : # Have room to downscale to less optimistic Belief.
#                    AgentData [ Agent ] [ 1 ] [ 1 ] = AgentData [ Agent ] [ 1 ] [ 1 ] + 1
#                    WorldViewChangeIndicator [ Agent ] =   No change   # Reset after change.
#          elif WorldViewChangeIndicator =   Upscale  :
#               if AgentData [ Agent ] [ 1 ] [ 1 ] > 0 : # Have room to upscale to more optimistic Belief.
#                    AgentData [ Agent ] [ 1 ] [ 1 ] = AgentData [ Agent ] [ 1 ] [ 1 ] - 1
#                    WorldViewChangeIndicator [ Agent ] =   No change  # Reset after change.			   
#def AdjustPopulation ( ) :
#     RemoveList = list ( )
#     AddList = list ( )
#     NumberOfPregnanciesRequiredThisTick = NumberOfFemales [ LongAge + GestationTicks ] * BirthRate [ LongAge + GestationTicks ]
#     NumberOfPregnanciesAssignedThisTick = 0
#     for Agent in range ( 0, len ( AgentData ) ) :
# Age all Agents.
#          AgentData [ Agent ] [ 0 ] [ 0 ] = AgentData [ Agent ] [ 0 ] [ 0 ] + LongTick - math.floor ( LongTick / NumTicksPerCycle ) * NumTicksPerCycle # Cycle units
#          AgentData [ Agent ] [ 0 ] [ 1 ] = AgentData [ Agent ] [ 0 ] [ 0 ] + 1 # Advance age in LongTick units.
# Deal with pregnancies.
#          If AgentData [ Agent ] [ 0 ] 0 [ 3 ] > 0 : AgentData [ Agent ] [ 0 ] 0 [ 3 ] + 1 # Advance pregnancy status.
#          If AgentData [ Agent ] [ 0 ] 0 [ 3 ] < 0 : AgentData [ Agent ] [ 0 ] 0 [ 3 ] = AgentData [ Agent ] [ 0 ] 0 [ 3 ] - 1 # Prevent pregnancy too soon after last birth.
#          If AgentData { Agent ] [ 0 ] [ 0 ] >= MaturityAge and \ # Only mature Females can become pregnant.
#          if NumberOfPregnanciesAssignedThisTick <= NumberOfPregnanciesRequiredThisTick and \ # Need more new pregnancies this Tick.
#          If AgentData [ Agent ] [ 0 ] [ 3 ] <= - PregnancyDelayTicks and \ : # Last birth was sufficiently long ago that a new pregnancy is allowed.
#          If random.random ( 0 , 1 ) > NumberOfPregnanciesAssignedThisTick / NumberOfPregnanciesRequiredThisTick : 
#               PregnancyStatus = 1 # Indicates pregnant, in first Tick of GestationTicks period.
#               NumberOfPregnanciesAssignedThisTick = NumberOfPregnanciesAssignedThisTick + 1
# Prepare to add some Agents (newborns).
#          if AgentData [ Agent ] [ 0 ] [ 4 ] >= GestationTicks : # Due this LongTick.
#               AddList.append ( Agent )
# Prepare to remove some Agents.
#          if random.random ( 0 , 1 ) <= DeathRate [ AgentData [ math.floor ( Agent ] [ 0 ] [ 0 ] ] / NumTicksPerCycle ) ] ] : # Death by statistics.
#               RemoveList.append ( Agent ) 
#          If NeedsNotMetIndicator [ Agent ] = True : # Death by persistent Needs shortfall.
#               RemoveList.append ( Agent )
# Remove Agents while not relying on loop counter based on len ( AgentData ).
#     for RemoveIndex in range ( len ( RemoveList ) , 0 , - 1 ) : # Avoid incorrect removals by starting at highest index and working down.
#          del AgentData [ RemoveIndex ]
# Add newborns due this LongTick while not relying on loop counter based on len ( AgentData )..
#    for AddIndex in range ( 0 , len ( AddList ) ) :
#               MotherAge = AgentData [ AddIndex ] [ 0 ] [ 0 ]
#               NewBornGender =  Female  # Provisional.
#               if random.random  ( 0 , 1 ) > NumberOfMales [ MotherAge ] / NumberOfFemales [ MotherAge ] : NewBornGender =  Male 
#               NewBornPregnancyStatus = 0 # Assume  Female .
#               if NewBornGender =  Male  : PregnancyStatus = - 99 # Very crude mechanism to prevent males from getting pregnant or giving birth.
#               NewBornBirthDayTick = LongTick - ( math.floor ( LongTick / NumTicksPerCycle ) - 1 ) * NumTicksPerCycle
#               NewBornAge = 0
#               NewBornLongAge = 0
#               NewBornPersonalData = ( NewBornAge , NewBornLongAge , NewBornBirthDayTick , NewBornGender , NewBornPregnancyStatus )
#               NewBornWorldViewData = AgentData [ AddIndex ] [ 1 ] [ : ] # Same as mother.
#               NewBornAffinityData = AgentData [ AddIndex ] [ 2 ] [ : ]
#               NewBornBiasesData = AgentData [ AddIndex ] [ 3 ] [ : ]
#               NewBornNeedsData = AgentData [ AddIndex ] [ 4 ] [ : ]
#               NewBornClaimsData = AgentData [ AddIndex ] [ 5 ] [ : ]
#               NewBornAllocationsData = AgentData [ AddIndex ] [ 6 ] [ : ]
#               InsertLocation = index ( AgentData [ AddIndex ] [ 1 ] [ 2 ] ) # Insert in same Power block as mother.
#               AgentData.insert ( InsertLocation, ( ( NewBornPersonalData , NewBornWorldViewData , NewBornAffinityData , NewBornBiasesData , \
#                    NewBornNeedsData , NewBornClaimsData , NewBornAllocationsData ) )#

def DisplayWorld ( ) :
    pass

Main ( )
